//*********************************************************************
//*
//* Nacharbeitssource für INPA
//*
//*********************************************************************
//* History         : 
//* 09.12.03 AB V0.01 Ersterstellung Grundumfang
//* 15.12.03 AB V0.01 Variantefeststellung: E90x, E60X,E60,E70, weil bestimmte Jobs nur fuer eine Variante zutreffen.
//*             V0.01 s_status_szl fuer E90X eingefuegt.
//* 19.01.04 AB V0.01 s_status_rpa_fasta: STAT_WEG_LETZTE_PANNE_TEXT und STAT_WEG_VORLETZTE_PANNE_TEXT eingefuegt.
//* 05.02.04 AB V0.01 s_status_analog_afs neu
//* 16.02.04 rd V0.02 Umstellung auf 32-Bit INPA
//* 08.12.04 AB V0.03 E60X_PLUS eingefuegt
//* 29.06.05 Ku V0.03 HDC auskommentiert, da beim E90-16 nicht aktiviert (SW Fehler)
//* 02.08.05 Ku V1.00 Fehlerbereinigung
//* 04.12.05 Ku V2.00 Update fuer E6x und E90-16
//* 13.06.06 Ku V3.00 E70 Update
//* 22.05.07 sh V3.01 Neu übersetzt wegen fehlender deutscher Textdatei
//* 01.02.08 Ku V4.00 RPA aktualisiert
//**********************************************************************
#include "inpa.h"
#include "bmw_std.h"

// Titel, Version, Verantwortung, Steuergerät
string titel   = "DXC8 PLUS,EHB3";   // Titel Nacharbeitsprogramm
string version = "4.00";                                     // Version Nacharbeitsprogramm
string origin  = "BMW EF-62 Kusch";                          // Verantwortung Nacharbeitsprogramm
string sgbd    = "DXC8_P/V5.00,DXC_90/V4.00,DXC_70/V5.00,DSC_60PP/V1.00";                                   // Steuergerät
string gruppe  = "D_DSC";                                    // Gruppendatei

string speicher_lesen_parameter="";
// Moegliche Speicher-Parameter: "LAR;FLASH;UIFM;ROMI;ROMX;RAMIS;RAMIL;RAMXX;NVRAM";
// Bei Leerstring erfolgt kein Menüpunkt Speicher Lesen

// allgemeine globale Variable
string text_var;
int    int_diag;
string diag_index;
real   zahlen_var;
int    ganz_zahl;
int    int_var;
bool   logik_var;
string job_state;    // JOB_STATUS Variable
int    input_state;  // Eingabestatus
int    input_ok=0;   // Eingabe  mit OK beendet
int    a=0;          // Abbruchkennung bei der Entluefterroutine
int    dauertest=0;
string steuer_text_dsc="";               // Steuervariable
int i=0;      //Zaehler

string vl       = "vorne links"  ;      // Radposition
string vr       = "vorne rechts" ;      // Radposition
string hl       = "hinten links" ;      // Radposition
string hr       = "hinten rechts";      // Radposition

string erg_text = "";
bool   bb       = FALSE;
real   re       = 0.0;

int    p1       = 1;
int    p2       = 10;
int    p3       = 19;
int    p4       = 28;
int    p5       = 38;
int    p6       = 46;
int    p7       = 59;

BLS_1()     // Pruefung auf betaetigte Bremse
{
    userboxclose(0);
    setcolor(1,10);            // gruener Bildschirm
    userboxopen(0,20,20,4,50,
    "Entlueftungroutine ","  ");
    userboxftextout(0,
    "    "+"Bremspedal betaetigen !",1,0,0,1);

    dauertest=12;                  
       while (dauertest>0){
         INPAapiJob(sgbd,"STATUS_DIGITAL","","STAT_BREMSLICHT_SCHALTER_EIN");
         INPAapiResultInt(int_var,"STAT_BREMSLICHT_SCHALTER_EIN",1);
         delay(300);
           if (int_var==1)dauertest=0;
         dauertest=dauertest-1;
       }
          
       if (int_var==0){
       INPAapiJob(sgbd,"STEUERN_STOP","","");
       setcolor(1,4);            // roter Bildschirm
       userboxclose(0);    
       userboxopen(0,20,20,4,50,
       "!!! Warnung !!!","  ");
       userboxftextout(0,
       "    "+"Bremse wurde nicht betaetigt !!!",1,0,0,1);
       userboxftextout(0,
       "    "+"Entluefterroutine wird abgebrochen",2,0,0,1);
       a=1;
       delay(4000);
       }
  }

BLS_0()     // Pruefung auf geloeste Bremse
{
    userboxclose(0);
    setcolor(1,15);            // blauer Bildschirm
    userboxopen(0,20,20,4,50,
    "Entlueftungroutine ","  ");
    userboxftextout(0,
    "    "+"Bremspedal loesen !",1,0,0,1);

    dauertest=12;              
       while (dauertest>0){
         INPAapiJob(sgbd,"STATUS_DIGITAL","","STAT_BREMSLICHT_SCHALTER_EIN");
         INPAapiResultInt(int_var,"STAT_BREMSLICHT_SCHALTER_EIN",1);
         delay(300);
           if (int_var==0)dauertest=0;
         dauertest=dauertest-1;
       }
          
       if (int_var==1){
       INPAapiJob(sgbd,"STEUERN_STOP","","");
       setcolor(1,4);            // roter Bildschirm
       userboxclose(0);    
       userboxopen(0,20,20,4,50,
       "!!! Warnung !!!","  ");
       userboxftextout(0,
       "    "+"Bremse wurde nicht geloest !!!",1,0,0,1);
       userboxftextout(0,
       "    "+"Entluefterroutine wird abgebrochen",2,0,0,1);
       a=1;
       delay(4000);
       }
  }


// start of :#include "bmw_std.src"
//**********************************************************************
//*
//* INPA Library-Funktionen BMW_STD.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 05.05.2000 rd V0.01 Ersterstellung
//* 23.06.2000 rd V0.02 Überarbeitung für E65 und E85
//* 04.07.2000 rd V0.03 Überarbeitung der Funktionen
//* 08.11.2000 rd V0.04 AIF Lesen Results überarbeitet
//* 01.03.2001 rd V0.05 m_status_flag neu hinzu
//* 02.03.2001 rd V0.06 m_steuern_flag neu hinzu
//* 18.05.2001 rd V0.07 AIF-Ausgabe verbessert
//* 25.04.2002 rd V0.08 Erweiterung HS_LESEN
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Erweiterung Ident für DS2
//* 19.11.2002 rd V1.02 FS_MODE erweitert um PCODEs
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//*            rd V2.00 Entfernung EldiAuftragLesen, EldiAuftragEingeben
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Hinweis im Hauptfenster, wenn Simulationsmodus aktiv ist.
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//**********************************************************************
string package="3.01";

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************

// Umrechnungsfaktoren deutsch / englisch
real   m_c    = 1.0;        // Grad Celsius -> Fahrenheit z = x * m_c + a_c
real   a_c    = 0.0;
real   m_km   = 1.0;     // km           -> miles      z = x * m_km
real   m_l    = 1.0;     // Liter        -> Gallon US  z = x * m_l

// für Info
string sgbd_ecu;
string sgbd_origin;
string sgbd_revision;
string sgbd_package;
string sgbd_sprache;
string sgbd_comment;
string gruppe_ecu;
string gruppe_origin;
string gruppe_revision;
string gruppe_comment;

// für Status-Menü
bool   m_status_flag=TRUE;
// True Status-Menü wird angezeigt

// für Steuern-Menü
bool   m_steuern_flag=TRUE;
// True Steuern-Menü wird angezeigt

// für FS_LESEN speichern
bool   fs_lesen_save_as_flag;

// für IS_LESEN speichern
bool   is_lesen_save_as_flag;

// für HS_LESEN speichern
bool   hs_lesen_save_as_flag;

// für FS_LESEN
bool   fs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LESEN
bool   is_lesen_flag;
// True wenn JOB vorhanden

// für HS_LESEN
bool   hs_lesen_flag;
// True wenn JOB vorhanden

// für IS_LOESCHEN
bool   is_loeschen_flag;
// True wenn JOB vorhanden

// für HS_LOESCHEN
bool   hs_loeschen_flag;
// True wenn JOB vorhanden

// Handle für FS_LESEN
int    f_ort_nr_buffer   = 0;
int    f_ort_text_buffer = 0;

//  In INPA.INI wird festgelegt ob
//   nach FS- IS-, HS-Löschen automatisch wieder gelesen wird.
bool   deleteread_flag;

// Wenn Ediabas im Simulationsmode läuft, dies im Hauptfenster anzeigen
bool   simulation_flag;

// für Ident Screen, bzw. SVK Screen bei UDS (ISO 14229)
int ident_typ;
// 1= DS2
// 2= BMW Fast
// 3= UDS (ISO 14229)


// für SPEICHER_LESEN
bool   speicher_lesen_flag;
// True wenn JOB vorhanden
bool   speicher_lesen_lar_flag;
bool   speicher_lesen_uifm_flag;
bool   speicher_lesen_romi_flag;
bool   speicher_lesen_romx_flag;
bool   speicher_lesen_nvram_flag;
bool   speicher_lesen_ramis_flag;
bool   speicher_lesen_ramxx_flag;
bool   speicher_lesen_flash_flag;
bool   speicher_lesen_ramil_flag;

// für Speicher lesen Ausgabe
string speicher_lesen_text         = "";
string speicher_lesen_seg_adr_anz  = "";
string speicher_lesen_adresse      = "0x000000";
int    speicher_lesen_anzahl       = 64;

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern ScriptInit(); // befindet sich im Hauptprogramm

// start of :#include "BATTERIE.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen BATTERIE.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 01.04.2004 rd V2.01 Im Fehlerfalle delay eingebaut
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* ShowBatteryIgnition
//*
//* Anzeige des Batterie- und Zündungs-Status
//*
//**********************************************************************
ShowBatteryIgnition()
{
  bool   fehlerflag;    // Fehler aufgetreten
  bool   fehlerflag2;   // Fehler aufgetreten
  bool   zuendung;      // Zündung ein/aus
  bool   batterie;      // Batterie ein/aus
  int    wert;          // allgemeine Variable

  ftextout("Batterie :", 0,5,1,0);
  ftextout("Zündung  :", 0,45,1,0);

  INPAapiJob("UTILITY","STATUS_UBATT","","");
  INP1apiResultInt(fehlerflag,wert,"STAT_UBATT",1);
  if ((fehlerflag!=TRUE) || (wert==0))
  {
    batterie=FALSE;
    zuendung=FALSE;
  }
  else
  {
    batterie=TRUE;
    INPAapiJob("UTILITY","STATUS_ZUENDUNG","","");
    INP1apiResultInt(fehlerflag2,wert,"STAT_ZUENDUNG",1);
    if ((fehlerflag2!=TRUE) || (wert==0))
      zuendung=FALSE;
    else
      zuendung=TRUE;
  }
  digitalout(batterie, 0,20,"","");
  if (batterie==TRUE)
    ftextout("ein  ", 0,25,1,0);
  else
  {
    if (fehlerflag==TRUE)
    {
      ftextout("aus  ", 0,25,1,0);
    }
    else
    {
      ftextout("---  ", 0,25,1,0);
    }
  }

  digitalout(zuendung, 0,62,"","");
  if (zuendung==TRUE)
    ftextout("ein  ", 0,67,1,0);
  else
  {
    if (fehlerflag2==TRUE)
    {
      ftextout("aus  ", 0,67,1,0);
    }
    else
    {
      ftextout("---  ", 0,67,1,0);
    }
  }

  if ((fehlerflag!=TRUE) || (fehlerflag2!=TRUE))
  {
    delay(2000);
  }
}
// -- EOF --
// end of :#include "BATTERIE.SRC"
// start of :#include "GRP_INFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GRP_INFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 EDIABAS.INI-Abfrage ob Simulationsmode aktiv ist
//* 18.10.2006 GA V3.01 Abfrage ob EDIABAS im Simulationsmodus läuft ist jetzt nicht mehr auf Pfad c:\windows\ediabas.ini beschränkt
//**********************************************************************

//**********************************************************************
//*
//* GruppenDateiInfo
//*
//* Versionsinformationen über Gruppendatei
//*
//**********************************************************************
import32 "C" lib "api32.DLL::__apiGetConfig" ApiGetConfig(in:long Handle,in: string Name,out: string Buffer, returns: int ReturnedValue);
GruppenDateiInfo( in: string grp,
                  inout: string grp_ecu, inout: string grp_origin,
                  inout: string grp_revision, inout: string grp_comment)
{
  string CurDir;
  string Temp;
  string Puffer;
  int    Size;
  long   PufferSize;
  int    ret_int;
  string BS;
  string CR;
  int    pos1;
  int    pos2;
  int    simulation;
  int    input;
  long   Handle;
  int    Returned;
  string ini_path= "??????????????????????";//Variable muß ausreichend lang vorbelegt sein!
  //                C:\ec-apps\ediabas\bin

  chr( 92, BS ); // '\'
  chr( 13, CR );

  // Pfad für EDIBAS.INI ermitteln
  // WERT 2 wurde durch Tests ermittelt
  Handle=2;
  ApiGetConfig(Handle,"EDIABASINIPATH",ini_path,Returned);
  //Abfrage, ob EDIABAS im Simulationsmodus betrieben wird. Hinweisfenster erfolgt im Hauptfenster s_main
  GetPrivateProfileInt("Configuration","Simulation",2,ini_path+BS+"ediabas.ini",simulation);
  if (simulation == 1) simulation_flag= TRUE;
  else simulation_flag= FALSE;

  Size=256;
  space(CurDir,Size);
  GetCurrentDirectory(256, CurDir, ret_int);
  SetCurrentDirectory("\EDIABAS\BIN", ret_int);

  Size=1024;
  space(Puffer,Size);
  inttolong(Size, PufferSize);
  XTRACT("\ediabas\ecu"+ BS + grp + ".grp", 1, Puffer, PufferSize, ret_int);

  grp_ecu="";
  instr(pos1, 0, Puffer, "ECU:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 4;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_ecu, Puffer, pos1, pos2 - pos1);
  }

  grp_origin="";
  instr(pos1, 0, Puffer, "ORIGIN:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 7;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
      midstr(grp_origin, Puffer, pos1, pos2 - pos1);
  }

  grp_revision="";
  instr(pos1, 0, Puffer, "REVISION:");
  if (pos1 >= 0)
  {
    pos1 = pos1 + 9;
    instr(pos2, pos1, Puffer, CR );
    if (pos2 > pos1)
    midstr(grp_revision, Puffer, pos1, pos2 - pos1);
  }

  grp_comment="";
  pos1=0;
  pos2=0;
  while ((pos1 >= 0) && (pos2 >= 0))
  {
    instr(pos1, pos2, Puffer, "ECUCOMMENT:");
    if (pos1 >= 0)
    {
      pos1 = pos1 + 11;
      instr(pos2, pos1, Puffer, CR );
      if (pos2 > pos1)
      {
        midstr(Temp, Puffer, pos1, pos2 - pos1);
        grp_comment=grp_comment+Temp+",";
      }
    }
  }
  SetCurrentDirectory(CurDir, ret_int);
}
// -- EOF --
// end of :#include "GRP_INFO.SRC"
// start of :#include "SGBDINFO.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SGBDINFO.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//**********************************************************************

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern SgbdInfo(in: string sg,
                inout: string sg_ecu, inout: string sg_origin,
                inout: string sg_revision, inout: string sg_package,
                inout: string sg_comment, inout: string sg_sprache);

//**********************************************************************
//*
//* SgbdInfo
//*
//* Versionsinformationen über SGBD
//*
//**********************************************************************
SgbdInfo( in: string sg,
          inout: string sg_ecu, inout: string sg_origin,
          inout: string sg_revision, inout: string sg_package,
          inout: string sg_comment, inout: string sg_sprache)
{
  INPAapiJob(sg,"INFO","","");
  INPAapiResultText(sg_ecu,"ECU",1,"");
  INPAapiResultText(sg_revision,"REVISION",1,"");
  INPAapiResultText(sg_package,"PACKAGE",1,"");
  INPAapiResultText(sg_origin,"ORIGIN",1,"");
  INPAapiResultText(sg_comment,"COMMENT",1,"");
  INPAapiResultText(sg_sprache,"SPRACHE",1,"");
}

// -- EOF --
// end of :#include "SGBDINFO.SRC"
// start of :#include "SGBDINPA.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen SgbdInpa.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Gezielte Ausgabe, wenn Gruppendatei oder SGBD nicht existiert
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//* 18.10.2006 GA V3.01 Check bezüglich auf Gruppen-Simulationsdatei, sowie "Identification error" erweitert
//* 24.10.2006 GA V3.02 Überprüfung ob T_GRTB.PRG vorhanden eingebaut
//**********************************************************************

//**********************************************************************
//*
//* SgbdInpaCheck
//*
//* Überprüfung ob SGBD zu INPA passt
//*
//**********************************************************************
SgbdInpaCheck()
{
  string sgbd_version;             // für Versionskontrolle
  string inpa_version;             // für Versionskontrolle
  string inpa_sprache="deutsch"; // für Sprachvariante
  string variante="???";           // für Variantenkontrolle
  string err_text;                 // Fehlertext
  int    errorcode;                // Errorcode
  bool   fehlerflag;               // Fehlerflag
  string temp;
  string temp1;
  string temp2;
  int    i;
  int    k;
  int    kk;                       // für neue VersionsnummernKontrolle
  int    ii;
  int    a;
  int    aa;
  int    i1;
  int    i2;
  int    i3;                       // für neue VersionsnummernKontrolle
  string sgbd_String_Lang;
  string sgbd_von_inpa_version;
  string ver_temp;
  string ver_temp1;
  string ver_temp2;
  string ver_temp3="--";
  real   Version_SGBD;
  real   Version_INPA;
  string CurDir;                   // Zur Prüfung ob Gruppendatei exisiert
  int    ret_int;
  int    Size;
  int    filecheck;
  string hinweis_text;

  settitle(titel+" Version "+version);
  a=0;
  ii=0;
  i3=0;
  kk=0;
  aa=0;
  i=0;
  k=0;
  fehlerflag=FALSE;
  temp1="";
  temp2="";

  instr(i,k,","+gruppe+",",",");
  while ((i >= 0) && (fehlerflag == FALSE))
  {
    k=i+1;
    instr(i,k,","+gruppe+",",",");
    if (i >= 0)
    {
      midstr(temp,","+gruppe+",",k,i-k);
      INPAapiJob(temp,"INITIALISIERUNG","","");
      INP1apiResultText(fehlerflag,variante,"VARIANTE",0,"");
      if (fehlerflag == TRUE) gruppe=temp;
      else
      {
        INP1apiErrorCode(errorcode);
        if (errorcode == 36)//Fehlende oder fehlerhafte Simulationsdatei
        {
           Size=256;
           space(CurDir,Size);
           GetCurrentDirectory(256, CurDir, ret_int);
           SetCurrentDirectory("\EDIABAS\SIM", ret_int);
           fileexist(temp+".SIM",filecheck);
           SetCurrentDirectory(CurDir, ret_int);
           if (filecheck == 0)
           {
             temp1= temp1+", "+temp+".SIM";//Fehlerhafte Simulationsdatei
           }
           else
           {
             temp2= temp2+", "+temp+".SIM";//Fehlende Simulationsdatei
           }
        }
      }
    }
  }

  instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
  instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
  if ((i == 0) || (k == 0))
       hinweis_text= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
  else hinweis_text= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an

  if (fehlerflag == FALSE)
  {
     //Fehlende oder fehlerhafte Gruppen-Simulationsdatei
     if (errorcode == 36)
     {
        //Fehlerhafte Simulationsdatei
        if (temp1 != "")
        {
          strlen(k,temp1);
          instr(i,k,temp1+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp1+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp1,temp1,1,k);//Kommata vor und hinter temp1 ausschneiden
          temp1= "Fehlerhafte Simulationsdatei: "+temp1+CRLF;
        }
        //Fehlende Simulationsdatei
        if (temp2 != "")
        {
          strlen(k,temp2);
          instr(i,k,temp2+",",",");//letztes Zeichen ein ','?
          if (i != -1) k= k-1;     //Zeichenlänge um 1 kürzen
          instr(i,0,temp2+",",",");//erstes Zeichen ein ','?
          if (i == 0) midstr(temp2,temp2,1,k);//Kommata vor und hinter temp2 ausschneiden
          temp2= "Fehlende Simulationsdatei  : "+temp2+CRLF;
        }

        messagebox("Variantenkontrolle",
                   "Fehler!"+CRLF+
                   temp1+//Fehlerfafte Gruppen-Simulationsdateien
                   temp2+//Fehlende     -//-
                   "Das Programm wird abgebrochen!");
        exit();
     }

     //Gruppendatei vorhanden?
     Size=256;
     space(CurDir,Size);
     GetCurrentDirectory(256, CurDir, ret_int);
     SetCurrentDirectory("\EDIABAS\ECU", ret_int);
     fileexist(gruppe+".GRP",filecheck);
     SetCurrentDirectory(CurDir, ret_int);
     if (filecheck == 0)//Gruppendatei vorhanden, SGBD-, Kommunikationsfehler hier ausgeben
     {
       INP1apiErrorText(err_text);//Fehler beim Aufruf der VARIANTE?
       if (errorcode == 92)//92=SYS-0002: SG-Variantenbeschreibungsdatei (SGBD) nicht gefunden
       {
         //T_GRTB.PRG vorhanden?
         Size=256;
         space(CurDir,Size);
         GetCurrentDirectory(256, CurDir, ret_int);
         SetCurrentDirectory("\EDIABAS\ECU", ret_int);
         fileexist("T_GRTB.PRG",filecheck);
         SetCurrentDirectory(CurDir, ret_int);
         if (filecheck == 0)//T_GRTB.PRG ist vorhanden, somit fehlt die SGBD.
         {
           messagebox("Variantenkontrolle",
                      "Fehler!"+CRLF+
                      err_text+". "+CRLF+
                      " "+CRLF+
                      "Das Steuergerät läßt sich zwar über die Gruppendatei: "+gruppe+".GRP"+" ansprechen,"+CRLF+
                      "aber zur Diagnose fehlt eine entsprechende SGBD (*.PRG) im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                      " "+CRLF+
                      "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                      " "+CRLF+
                      "Das Programm wird abgebrochen!");
         }
         else//T_GRT.PRG fehlt
         {
           messagebox("Variantenkontrolle",
                     "Fehler!"+CRLF+
                     err_text+". "+CRLF+
                     " "+CRLF+
                     "Die Datei T_GRTB.PRG fehlt im Verzeichnis ..\EDIABAS\ECU"+CRLF+
                     " "+CRLF+
                     "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
                     " "+CRLF+
                     "Das Programm wird abgebrochen!");
         }
       }
       else if (errorcode == 102)//102= Identification error
       {
         instr(i,0,gruppe,"d");//erstes Zeichen ein 'd'?
         instr(k,0,gruppe,"D");//erstes Zeichen ein 'D'?
         if ((i == 0) || (k == 0))
              temp1= "das Steuergerät liefert einen falschen Varianten- und / oder Diagnose-Index.";// bis F01: Gruppendateien fangen mit D_... an
         else temp1= "das Steuergerät liefert einen falschen SGBD-Index.";//gilt ab F01, Gruppendateien fangen mit G_... an
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                    hinweis_text+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
       else //alle anderen Fehler
       {
         messagebox("Variantenkontrolle",
                    "Fehler! Aufruf über Gruppendatei : "+gruppe+".GRP"+CRLF+
                    " "+CRLF+
                    err_text+". "+CRLF+
                    " "+CRLF+
                    " "+CRLF+
                    "Das Programm wird abgebrochen!");
       }
     }
     else//Gruppendatei nicht vorhanden
     {
        messagebox("Variantenkontrolle",
        "Fehler! Gruppendatei : "+gruppe+".GRP "+CRLF+
        "existiert nicht im Verzeichnis ..\EDIABAS\ECU"+CRLF+
        " "+CRLF+
        "Aktualisieren Sie SGBDen, Gruppendateien und INPA Scripte regelmäßig!"+CRLF+
        " "+CRLF+
        "Das Programm wird abgebrochen!");
     }
     exit();
  }

  i1=0;
  i2=0;
  instr(i1,0,","+sgbd+",",","+variante+",");
  if (i1 < 0)
  {
    instr(i2,0,","+sgbd+",",","+variante+"/");
    if (i2 < 0)
    {
      messagebox("Variantenkontrolle",
                 "Gesuchtes Steuergerät: '"+sgbd+"' nicht gefunden. "+CRLF+
                 "Gefundenes Steuergerät: '"+variante+"'. "+CRLF+
                 " "+CRLF+
                 "Sie besitzen entweder eine veraltete ..\EDIABAS\ECU\T_GRTB.PRG Datei, und / oder"+CRLF+
                 hinweis_text+CRLF+
                 " "+CRLF+
                 "Das Programm wird abgebrochen!");
      exit();
    }

    ver_temp3 = "--";
    instr(ii,i2,sgbd+",",",");
    if (ii >= 0)
    {
      midstr(ver_temp3,sgbd+",",i2,ii);
      instr(i3,0,ver_temp3,"/");
      if (i3 >= 0)
      {
        a = i2+i3+1;
        aa = ii-i2+i3-1;
        midstr(ver_temp3,sgbd+",",a,aa);
      }
    }
  }

  sgbd_String_Lang = sgbd;
  sgbd=variante;

//
// Info: Informatinon bei aufruf ohne BMW_STD.SRC
//
// ####################################################
// # //für Info                                       #
// #   string sgbd_ecu;                               #
// #   string sgbd_origin;                            #
// #   string sgbd_revision;                          #
// #   string sgbd_package;                           #
// #   string sgbd_sprache;                           #
// #   string sgbd_comment;                           #
// #   string gruppe_ecu;                             #
// #   string gruppe_origin;                          #
// #   string gruppe_revision;                        #
// #   string gruppe_comment;                         #
// #                                                  #
// #   #include "SgbdInfo.src"                        #
// ####################################################
//
//
  SgbdInfo(sgbd, sgbd_ecu, sgbd_origin, sgbd_revision, sgbd_package, sgbd_comment, sgbd_sprache);
// Bitte VARIABLEN als Globale variable aktivieren und Include (siehe Block //INFO)
//
//

  //Versionskontrolle Auf 3 stellen vor / hinter dem "."
  instr(i3,0,ver_temp3,"V");
  if(i3>=0)
  {
    instr(i2,0,ver_temp3,",");
    midstr(ver_temp3,ver_temp3,i3+1,i2-1);
    stringtoreal(ver_temp3,Version_INPA);
    realtostring(Version_INPA,"3.3",ver_temp3);
    midstr(sgbd_von_inpa_version,ver_temp3,0,2);
  }
  stringtoreal(version,Version_INPA);
  realtostring(Version_INPA,"3.3",version);
  midstr(inpa_version,version,0,2);

  stringtoreal(sgbd_revision,Version_SGBD);
  realtostring(Version_SGBD,"3.3",sgbd_revision);
  midstr(sgbd_version,sgbd_revision,0,2);

  temp=inpa_version;
  temp1=sgbd_version;

  if (ver_temp3 == "--")
  {
    // Vergleichen mit Versionsnummer INPA & SGBD
    if (inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!");
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }
  else
  {
    // Vergleichen mit Versionsnummer INPA(SGBD Vorwahl) & SGBD
    if (sgbd_von_inpa_version != sgbd_version)
    {
      messagebox("Versionskontrolle",
                 "Nicht zusammenpassende Versionen. "+CRLF+
                 "Fehlfunktion ist möglich!"+CRLF+CRLF+
                 "SGBD Version: "+ ver_temp3 +" (in INPA) "+CRLF+
                 "SGBD Version: "+ sgbd_revision +CRLF+
                 "INPA Version: "+ version);
    }
    else
    {
      if (temp == "0.")
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision+CRLF+
                     "INPA Version: "+version);
        }
        else
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "INPA Version: "+version);
        }
      }
      else
      {
        if (temp1 == "0.")
        {
          messagebox("Versionskontrolle",
                     "Programm noch in der Entwicklungsphase. "+CRLF+
                     "Fehlfunktion ist möglich!"+CRLF+CRLF+
                     "SGBD Version: "+sgbd_revision);
        }
      }
    }
  }

  if (inpa_sprache != sgbd_sprache)
  {
    messagebox("Sprachvariantenkontrolle",
               "Nicht zusammenpassende Sprachvariante. "+CRLF+
               "Fehlfunktion ist möglich!");
  }
}

// -- EOF --
// end of :#include "SGBDINPA.SRC"
// start of :#include "GRPCHECK.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen GrpCheck.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 12.03.2003 iS V1.05 Aufteilung der Funktionen(SgbdInpaCheck,GroupCheck)
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//* 05.04.2007 GA V3.01 Abfrage auf IS_ und HS_LOESCHEN implementiert
//* 20.04.2007 GA V3.02 FS-, IS-, HS_LESEN werden in einzelnen Tempdateien in ..\EDIABAS\BIN abgelegt
//**********************************************************************

//**********************************************************************
//*
//* GroupCheck
//*
//* Überprüfung der Gruppen-Info
//*
//**********************************************************************
GroupCheck()
{
  string err_text;                 // Fehlertext
  bool   fehlerflag;               // Fehlerflag
  string temp;
  int    sgbd_saetze;              // für Funktionen-Suche in SGBD
  string job_name;                 // JOBNMAE in SGBD
  int    i;

  fehlerflag=FALSE;
  i=0;

  GruppenDateiInfo(gruppe, gruppe_ecu, gruppe_origin, gruppe_revision, gruppe_comment);

  // Vorbelegung der Flags
  fs_lesen_flag       = FALSE;
  is_lesen_flag       = FALSE;
  speicher_lesen_flag = FALSE;
  is_loeschen_flag    = FALSE;
  hs_loeschen_flag    = FALSE;

  INPAapiJob(sgbd,"_JOBS","","");

  INP1apiResultSets(fehlerflag, sgbd_saetze);
  if (fehlerflag == FALSE)
  {
    INP1apiErrorText(err_text);
    messagebox("Unerwarteter Fehler", // sollte nie kommen
                err_text+". "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }
  i = 1;
  while ( i <= sgbd_saetze)
  {
    INPAapiResultText(job_name,"JOBNAME",i,"");
    if (job_name == "FS_LESEN" )       fs_lesen_flag=TRUE;
    if (job_name == "IS_LESEN" )       is_lesen_flag=TRUE;
    if (job_name == "HS_LESEN" )       hs_lesen_flag=TRUE;
    if (job_name == "IS_LOESCHEN" )    is_loeschen_flag=TRUE;
    if (job_name == "HS_LOESCHEN" )    hs_loeschen_flag=TRUE;
    if (job_name == "SPEICHER_LESEN" ) speicher_lesen_flag=TRUE;

    if ((fs_lesen_flag == TRUE) &&
        (is_lesen_flag == TRUE) &&
        (hs_lesen_flag == TRUE) &&
        (is_loeschen_flag == TRUE) &&
        (hs_loeschen_flag == TRUE) &&
        (speicher_lesen_flag) == TRUE) i = sgbd_saetze;
    i = i + 1;
  }
  if (speicher_lesen_parameter == "")  speicher_lesen_flag = FALSE;

  if (speicher_lesen_flag == TRUE)
  {
    instr(i, 0, ";"+speicher_lesen_parameter+";", ";LAR;");
    if ( i == -1 ) speicher_lesen_lar_flag = FALSE; else speicher_lesen_lar_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";FLASH;");
    if ( i == -1 ) speicher_lesen_flash_flag = FALSE; else speicher_lesen_flash_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";UIFM;");
    if ( i == -1 ) speicher_lesen_uifm_flag = FALSE; else speicher_lesen_uifm_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMI;");
    if ( i == -1 ) speicher_lesen_romi_flag = FALSE; else speicher_lesen_romi_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIS;");
    if ( i == -1 ) speicher_lesen_ramis_flag = FALSE; else speicher_lesen_ramis_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMIL;");
    if ( i == -1 ) speicher_lesen_ramil_flag = FALSE; else speicher_lesen_ramil_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";NVRAM;");
    if ( i == -1 ) speicher_lesen_nvram_flag = FALSE; else speicher_lesen_nvram_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";ROMX;");
    if ( i == -1 ) speicher_lesen_romx_flag = FALSE; else speicher_lesen_romx_flag = TRUE;

    instr(i, 0, ";"+speicher_lesen_parameter+";", ";RAMXX;");
    if ( i == -1 ) speicher_lesen_ramxx_flag = FALSE; else speicher_lesen_ramxx_flag = TRUE;
  }

  //IDENT-Typ ermitteln: DS2, BMW Fast oder UDS?
  INP1apiJob(sgbd,"IDENT","","");
  INP1apiResultText(fehlerflag,temp,"ID_DATUM_KW",1,"");//Hat nur DS2
  if ((fehlerflag == TRUE) && (temp != ""))
  {
    ident_typ= 1;//DS2
  }
  else//UDS, BMW Fast
  {
    INP1apiResultText(fehlerflag,temp,"ID_SGBD_INDEX",1,"");
    if ((fehlerflag == TRUE) && (temp != "")) ident_typ= 3; //Hat nur UDS (ISO 14229)
    else ident_typ= 2; //sonst BMW Fast
  }
}
// -- EOF --
// end of :#include "GRPCHECK.SRC"
// start of :#include "FS_LESEN.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen FS_LESEN.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 21.11.2000 rd V0.10 Umweltbedingungen als Zahl oder Text ( 0-n, Hex )
//* 02.03.2001 rd V0.11 Shadowspeicher umbenannt in Infospeicher
//* 25.04.2002 rd V1.00 Erweiterung HS_LESEN
//* 22.10.2002 rd V1.01 Erweiterung FS_LESEN
//*               V1.01 PCODE und PCODE7 Ausgabe neu
//*               V1.01 Fehlerbehandlung verbessert
//* 19.11.2002 iS V1.02 Fehlerbehandlung F_ORT_TEXT, F_UW_ANZ, F_PCODE
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 Fehlerausgaben korrigiert und erweitert
//* 28.06.2006 GA V3.01 Bei UDS: Ausgabe "F_UW_DATUM_ZEIT" durch "F_UW_ZEIT" ersetzt, da Result entfällt
//* 19.10.2006 GA V3.02 Bei DS2: wurde nicht angezogen da if-Bedingung nicht korrekt gewesen ist.
//*            GA V3.02 Result: F_UW_ZEIT von Unterprg.: fs_protokoll_uwb in fs_protokoll_uwb_uds verschoben
//*            GA V3.02 Result: F_EREIGNIS_DTC: Text wurde inverse ausgegeben
//* 07.02.2007 GA V3.03 Result: F_EREIGNIS_DTC: Erklärender Text, was ein Ereinis DTC ist, war falsch
//**********************************************************************

//**********************************************************************
//*
//* Globale Variablen
//*
//**********************************************************************
int    _FsMode        = 0x7FF; // alles ein
string _FsFileMode    = "w";
string _PreInfoFile   = "";
string _PostInfoFile  = "";
string _ApiFsJobName  = "FS_LESEN";

//**********************************************************************
//*
//* Deklaration der Funktionen
//*
//**********************************************************************
extern INPAapiFsMode_neu ( in: int FsMode, in: string FsFileMode,
                           in: string PreInfoFile, in: string PostInfoFile,
                           in: string ApiFsJobName);

extern INPAapiFsLesen_neu( in: string ecu, in: string FileName);

extern fs_protokoll_ort(in: int nr);
extern fs_protokoll_ort_uds(in: int nr);
extern fs_protokoll_PCode(in: int nr);
extern fs_protokoll_PCode7(in: int nr);
extern fs_protokoll_SAECode(in: int nr);
extern fs_protokoll_hfk(in: int nr);
extern fs_protokoll_hfk_uds(in: int nr);
extern fs_protokoll_art(in: int nr);
extern fs_protokoll_art_uds(in: int nr);
extern fs_protokoll_art_e(in: int nr);
extern fs_protokoll_uwb(in: int nr);
extern fs_protokoll_uwb_uds(in: int nr);
extern fs_protokoll_hex(in: int nr);
extern fs_protokoll_telantwort(in: int nr);

//**********************************************************************
//*
//* INPAapiFsMode_neu kompatibel mit INPAapiFsMode
//*
//**********************************************************************
INPAapiFsMode_neu(  in: int    FsMode,
                    in: string FsFileMode,
                    in: string PreInfoFile,
                    in: string PostInfoFile,
                    in: string ApiFsJobName)
{
  _FsMode       = FsMode;
  _FsFileMode   = FsFileMode;
  _PreInfoFile  = PreInfoFile;
  _PostInfoFile = PostInfoFile;
  _ApiFsJobName = ApiFsJobName;


  INPAapiFsMode(_FsMode, _FsFileMode, _PreInfoFile, _PostInfoFile, _ApiFsJobName);
  if (_ApiFsJobName=="") _ApiFsJobName="FS_LESEN";
}

//**********************************************************************
//*
//* INPAapiFsLesen_neu kompatibel mit INPAapiFsLesen
//*
//**********************************************************************
INPAapiFsLesen_neu( in: string ecu, in: string FileName)
{
  string _ecu;
  string _FileName;
  bool   rc;
  int    i;
  int    k;
  int    len;
  int    x1;
  long   xL;
  string temp1;
  string temp2;
  string temp3;
  string temp11;
  string temp12;
  string temp21;
  string temp22;
  int    F_VERSION;
  string JOB_STATUS;
  string JOB_MESSAGE;
  string VARIANTE;
  int    SETS;
  int    UW_SETS;
  string FS_CODE;
  string F_PCODE;
  string F_PCODE7;
  string F1_VERSION;
  int    errorcode;                // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext
  string errorcode_text;           // EDIABAS Fehlernummer als Text

  string sgbd_version;             // aus INFO auslesen, um bei Fehlern die Version angeben zu können

  _ecu      = ecu;
  _FileName = FileName;


  //SGBD-Version auslesen
  sgbd_version= "???";
  INPAapiJob(_ecu,"INFO","","");
  INP1apiResultText(rc, sgbd_version, "REVISION", 1, "");

  INPAapiJob(_ecu, _ApiFsJobName,"","");
  INP1apiResultInt(rc, F_VERSION, "F_VERSION",1 );

  INP1apiErrorCode(errorcode);

//UDS:
  if ((rc == TRUE) && ( F_VERSION == 3 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort_uds(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="??????";
            StrArrayWrite(f_ort_text_buffer,i,temp1);

            INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
            if (rc == TRUE)
            {
              GetBinaryDataString (temp1,len);
              midstr(temp1,temp1,0,6);
            }
            else
            {
              temp1= "??????";
              filewrite("");
              filewrite("### Fehler beim Lesen des Results: F_HEX_CODE ###");
              filewrite("");
              INP1apiErrorCode(errorcode);
              if (errorcode != 0)
              {
                inttostring(errorcode, errorcode_text);
                INP1apiErrorText(error_text);
                error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
                ftextout(error_text ,2,0,0,0);
              }
            }
            StrArrayWrite(f_ort_nr_buffer,i,temp1);

            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort_uds(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_SAECode(1);//0x200 von BMW Fast für PCode genommen
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk_uds(1);
                k=1;

                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb_uds(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_uds(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite("0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);

                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite("0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//BMW FAST:
  else if ((rc == TRUE) && ( F_VERSION == 2 ))
  {
    getdate(temp1);
    gettime(temp2);
    INPAapiResultSets(SETS);
    INPAapiResultText(VARIANTE, "VARIANTE", 0, "");
    INPAapiResultText(JOB_STATUS, "JOB_STATUS", SETS, "");
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite("");
    filewrite("Datum    : "+temp1+" "+temp2);
    if (_ecu != VARIANTE) filewrite("ECU      : "+_ecu);
    filewrite("JobStatus: "+JOB_STATUS);
    filewrite("Variante : "+VARIANTE+".PRG");
    filewrite("Version  : "+sgbd_version);
    filewrite( "-------------------------------------------------------------------------------");

    if ( JOB_STATUS == "OKAY")
    {
      filewrite( "");
      if (SETS == 1)
        filewrite( "           >>>>>>>>>> Kein Fehler gefunden <<<<<<<<<<<");
      else
      {
        inttostring(SETS-1,temp1);
        if ((SETS-1) < 10) temp1= " "+temp1;//Formatierung der Fehleranzahl, wenn sie kleiner 10 ist
        filewrite( "ERGEBNIS : "+temp1+" Fehler im Fehlerspeicher!");
        if ((_FsMode & 0x100) == 0)
        {
          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");
            if ((_FsMode & 0x01) != 0) fs_protokoll_ort(i);
            if ((_FsMode & 0x04) != 0) fs_protokoll_art(i);
            if ((_FsMode & 0x40) != 0) fs_protokoll_hex(i);
            i=i+1;
          }
        }
        else
        {
          // Detail lesen
          i=1;
          StrArrayDelete(f_ort_nr_buffer);
          StrArrayDelete(f_ort_text_buffer);

          while ( i < SETS )
          {
            INP1apiResultText(rc,temp1, "F_ORT_TEXT", i, "");
            if (rc != TRUE) temp1="????";

            StrArrayWrite(f_ort_text_buffer,i,temp1);
            INPAapiResultInt(x1, "F_ORT_NR", i);
            inttohexstring(x1, 4, temp1);
            StrArrayWrite(f_ort_nr_buffer,i,temp1);
            i=i+1;
          }

          i=1;
          while ( i < SETS )
          {
            if (_FsMode != 0)
              filewrite( "-------------------------------------------------------------------------------");

            StrArrayRead(f_ort_nr_buffer,i,FS_CODE);
            INPAapiJob(_ecu, _ApiFsJobName+"_DETAIL", "0x"+FS_CODE, "");
            INP1apiResultSets(rc, UW_SETS);
            if (rc == TRUE)
            {
              INPAapiResultText(JOB_STATUS, "JOB_STATUS", UW_SETS, "");
              if ( JOB_STATUS == "OKAY")
              {
                if ((_FsMode & 0x01)  != 0) fs_protokoll_ort(1);
                if ((_FsMode & 0x200) != 0) fs_protokoll_PCode(1);
                if ((_FsMode & 0x400) != 0) fs_protokoll_PCode7(1);
                if ((_FsMode & 0x20)  != 0) fs_protokoll_hfk(1);
                k=1;
                while ( k < UW_SETS )
                {
                  filewrite( "");
                  if ( UW_SETS > 2 )
                  {
                    inttostring(k,temp1);
                    filewrite( temp1 + ". Umweltsatz");
                  }
                  if ((_FsMode & 0x02) != 0) fs_protokoll_uwb(k);
                  k=k+1;
                }
                if ((_FsMode & 0x04) != 0) fs_protokoll_art(1);
                if ((_FsMode & 0x04) != 0) fs_protokoll_art_e(1);
                if ((_FsMode & 0x40) != 0) fs_protokoll_hex(1);
              }
              else
              {
                if ((_FsMode & 0x01) != 0)
                {
                  filewrite( "");
                  StrArrayRead(f_ort_text_buffer,i,temp2);
                  filewrite( "0x"+FS_CODE+"  "+temp2);
                }
                INP1apiResultText(rc,JOB_MESSAGE, "JOB_MESSAGE", UW_SETS, "");
                if (rc == TRUE)
                {
                     filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS+" --> "+JOB_MESSAGE) ;
                }
                else filewrite( _ApiFsJobName+"_DETAIL: JobStatus: "+JOB_STATUS);
                fs_protokoll_telantwort(UW_SETS);//Telegrammantwort zur Fehleranalyse mit ausgeben
              }
            }
            else
            {
              if ((_FsMode & 0x01) != 0)
              {
                filewrite( "");
                StrArrayRead(f_ort_text_buffer,i,temp2);
                filewrite( "0x"+FS_CODE+"  "+temp2);
              }
              INP1apiErrorText(temp1);
              filewrite( _ApiFsJobName+"_DETAIL: "+temp1);
            }
            i=i+1;
          }
        }
      }
    }
    filewrite( "===============================================================================");
    fileclose();
  }
//DS2
  else if (errorcode == 134)//134=SYS-0014: Result nicht gefunden: 'F_VERSION'
  {
    INPAapiFsLesen( _ecu, _FileName);
  }
//Fehlerhafter Aufruf
  else
  {
    INPAapiCheckJobStatus("OKAY");//Damit der Bediener die Fehlermeldung bestätigen muß
    getdate(temp1);
    gettime(temp2);
    INP1apiErrorText(temp3);
    fileopen ( _FileName, _FsFileMode);

    if (_ApiFsJobName == "IS_LESEN")
    {
        filewrite( "           I N F O S P E I C H E R   L E S E N");
        filewrite( "           -----------------------------------");
    }
    else
      if (_ApiFsJobName == "HS_LESEN")
      {
        filewrite( "           H I S T O R I E N S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------------");
      }
      else
      {
        filewrite( "           F E H L E R S P E I C H E R   L E S E N");
        filewrite( "           ---------------------------------------");
      }

    filewrite( "");
    filewrite( "Datum    : "+temp1+" "+temp2);
    filewrite( "ECU      : "+_ecu);
    filewrite( "JobStatus: "+JOB_STATUS+"-->"+temp3) ;
    filewrite( "-------------------------------------------------------------------------------");
    fileclose();
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für DS2 und BMW Fast
//*
//**********************************************************************
fs_protokoll_ort(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  INP1apiResultInt(rc,x1, "F_ORT_NR", i);
  if (rc == TRUE)
  {
    inttohexstring(x1, 4, temp1);
  }
  else
  {
    temp1="????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerort für UDS (ISO 14229)
//*
//**********************************************************************
fs_protokoll_ort_uds(in: int nr)
{
  int    i;
  int    len;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");

  INP1apiResultBinary(rc,"F_HEX_CODE",i);//Fehlerort Nr. bei UDS: 3 Bytes, daher mit long arbeiten. (kein INPAapiResultText(temp1, "F_ORT_NR", i, "");....!) ...ergibt diese Lösung
  if (rc == TRUE)
  {
    if (_ApiFsJobName == "FS_LESEN")
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,0,6);
    }
    else//IS_LESEN
    {
      GetBinaryDataString (temp1,len);
      midstr(temp1,temp1,2,6);//Byte 0, Zeichen 0 und 1 sind das severity Byte!
    }

  }
  else
  {
    temp1= "??????";
  }

  INP1apiResultText(rc,temp2, "F_ORT_TEXT", i, "");
  if (rc == TRUE)
  {
    filewrite( "0x"+temp1+"  "+temp2);
  }
  else
  {
    filewrite( "0x"+temp1+"  "+"??????");
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE
//*
//**********************************************************************
fs_protokoll_PCode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcodeText;
  string tempPcodeString;
  string tempPcodeHex;

  i=nr;
  INP1apiResultText(rc,tempPcodeString, "F_PCODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcodeText, "F_PCODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcodeHex);
        tempPcodeHex= "0x"+tempPcodeHex;
      }
      else
      {
        tempPcodeHex = "????";
      }
    }
    else
    {
      tempPcodeText = "????";
    }

    if (tempPcodeString == "??")
    {
      filewrite( "");
      filewrite( tempPcodeHex+"  "+tempPcodeText);
    }
    else
    {
      if (tempPcodeString != "--")
      {
        filewrite( "");
        filewrite( tempPcodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe PCODE7
//*
//**********************************************************************
fs_protokoll_PCode7(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempPcode7Text;
  string tempPcode7String;
  string tempPcode7Hex;

  i=nr;
  INP1apiResultText(rc,tempPcode7String, "F_PCODE7_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempPcode7Text, "F_PCODE7_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_PCODE7", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempPcode7Hex);
        tempPcode7Hex= "0x"+tempPcode7Hex;
      }
      else
      {
        tempPcode7Hex = "????";
      }
    }
    else
    {
      tempPcode7Text = "????";
    }

    if (tempPcode7String == "??")
    {
      filewrite( "");
      filewrite( tempPcode7Hex+"  "+tempPcode7Text);
    }
    else
    {
      if (tempPcode7String != "--")
      {
        filewrite( "");
        filewrite( tempPcode7Text);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe SAE Code für UDS
//*
//**********************************************************************
fs_protokoll_SAECode(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string tempSAECodeText;
  string tempSAECodeString;
  string tempSAECodeHex;

  i=nr;
  INP1apiResultText(rc,tempSAECodeString, "F_SAE_CODE_STRING", i,"");
  if (rc == TRUE)
  {
    INP1apiResultText(rc,tempSAECodeText, "F_SAE_CODE_TEXT", i, "");
    if (rc == TRUE)
    {
      INP1apiResultInt(rc,x1, "F_SAE_CODE", i);
      if (rc == TRUE)
      {
        inttohexstring(x1, 4, tempSAECodeHex);
        tempSAECodeHex= "0x"+tempSAECodeHex;
      }
      else
      {
        tempSAECodeHex = "????";
      }
    }
    else
    {
      tempSAECodeText = "????";
    }

    if (tempSAECodeString == "??")
    {
      filewrite( "");
      filewrite( tempSAECodeHex+"    "+tempSAECodeText);
    }
    else
    {
      if (tempSAECodeString != "--")
      {
        filewrite( "");
        filewrite( tempSAECodeText);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit
//*
//**********************************************************************
fs_protokoll_hfk(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;
  int f_hfk;
  int f_lz;

  i=nr;
  filewrite( "");

  INP1apiResultInt(rc,f_hfk,"F_HFK",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_hfk,temp1);
    if (f_hfk < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    filewrite( "Fehlerhäufigkeit: "+ temp1);
  }

  INP1apiResultInt(rc,f_lz,"F_LZ",i);
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="-1")
  {
    inttostring(f_lz,temp1);
    if (f_lz < 10) temp1= " "+temp1;//Formatierung der Nr des Logistikzählers, wenn sie kleiner 10 ist
    filewrite( "Logistikzähler  : "+ temp1);
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerhäufigkeit für UDS
//*
//**********************************************************************
fs_protokoll_hfk_uds(in: int nr)
{
  int    i;
  int    x1;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  filewrite( "");
  //FS Überlauf
  INP1apiResultInt(rc,x1, "F_UEBERLAUF", i);
  if ((rc == TRUE) && (x1==1))
  {
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    if (_ApiFsJobName == "IS_LESEN")
      filewrite("++++++++++++++++++++++++ Infospeicher ist übergelaufen! +++++++++++++++++++++++");
    else
      filewrite("+++++++++++++++++++++++ Fehlerspeicher ist übergelaufen! ++++++++++++++++++++++");
    filewrite( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
    filewrite( "");
  }

  //Fehlerhäufigkeit
  INP1apiResultInt(rc,x1, "F_HFK", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
   {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung der Nr der Fehlerhäufigkeit, wenn sie kleiner 10 ist
    }
  }
  filewrite( "Fehlerhäufigkeit: "+ temp1);

  //Heilungszähler
  INP1apiResultInt(rc,x1, "F_HLZ", i);
  if (rc == FALSE)
  {
     temp1 ="????";
  }
  else
  {
    if (x1 == -1)
    {
      temp1= "wird nicht unterstützt";
    }
    else
    {
      inttostring(x1,temp1);
      if (x1 < 10) temp1= " "+temp1;//Formatierung des Heilungszählers, wenn er kleiner 10 ist
    }
  }
  filewrite( "Heilungszähler  : "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten
//*
//**********************************************************************
fs_protokoll_art(in: int nr)
{
  int    i;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_SYMPTOM_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe erweiterte Fehlerarten
//*
//**********************************************************************
fs_protokoll_art_e(in: int nr)
{
  int    i;
  int    k;
  int    F_ART_ANZ;
  bool   rc;
  string temp1;
  string temp2;

  i=nr;
  INP1apiResultInt(rc,F_ART_ANZ, "F_ART_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_ART_ANZ > 0 )
    {
      k=0;
      while ( k < F_ART_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);
        INP1apiResultText(rc,temp1, "F_ART"+temp2+"_TEXT", i, "");
        if (rc == FALSE)  temp1 ="????";
        if (temp1 !="--") filewrite( "   "+ temp1);
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Fehlerarten für UDS
//*
//**********************************************************************
fs_protokoll_art_uds(in: int nr)
{//Symptome entfallen bei UDS!
  int    i;
  int    x1;
  bool   rc;
  string temp1;

  i=nr;
  filewrite( "");
  INP1apiResultText(rc,temp1, "F_READY_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_VORHANDEN_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  INP1apiResultText(rc,temp1, "F_WARNUNG_TEXT", i, "");
  if (rc == FALSE)  temp1 ="????";
  if (temp1 !="--") filewrite( "   "+ temp1);
  //Neu bei UDS:
  INP1apiResultInt(rc,x1, "F_EREIGNIS_DTC", i);
  if (rc == TRUE)
  {
    if (x1==0)
    {
      filewrite("   Dies ist kein Ereignis DTC. Das SG ist für den Fehlerspeicheintrag (DTC) verantwortlich.");
    }
    else if (x1==1)
    {
      filewrite("   Dies ein Ereignis DTC. Das SG ist somit nicht für den Fehlereintrag (DTC) verantwortlich.");
      filewrite("   Z.B. falsche oder fehlende Netzwerkinformationen.");
    }
    else
    {
      filewrite("   Fehler in SGBD! In Tabelle FOrtTexte, Spalte EREIGNIS_DTC muß 0 oder 1 stehen!");
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb(in: int nr)
{
  int    i;
  int    k;
  int    len;
  int    F_UW_ANZ;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  real   realval;
  int    pos;

  i=nr;
/*  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");
*/
  INP1apiResultText(rc,temp1, "F_UW_KM", i, "8L");
  if (rc == FALSE) temp1="    ????";
  if ((temp1 == "524280") && (ident_typ != 3)) temp1 = "-1";//Fehlerüberlauf für DS2 und BMW FAST, UDS liefert es von alleine

  temp2 =    "Kilometerstand                        ";
  filewrite( "   " + temp2 + temp1 + "     km");


  INP1apiResultInt(rc,F_UW_ANZ, "F_UW_ANZ", i);
  if (rc == TRUE)
  {
    if ( F_UW_ANZ > 0 )
    {
      k=0;
      while ( k < F_UW_ANZ )
      {
        k = k + 1;
        inttostring(k,temp2);

        INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
        if (rc == TRUE)
        {
          AnsiUpper(temp3,temp3);
        }
        else
        {
          temp3 = "????";
        }
        if ((temp3 == "0-N") || (temp3 == "HEX"))
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-20T");
          if (rc == FALSE) temp1="????                ";
          if (temp1 !="--                  ") //"--" + 18 Zeichen

          {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "28T");
              if (rc == FALSE) temp3="????                        ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
          }
        }
        else
        {
          INP1apiResultText(rc,temp1, "F_UW"+temp2+"_TEXT", i, "-40T");
          if (rc == FALSE) temp1="????                                    ";
          if (temp1 !="--                                      ")
           {
            if ((_FsMode & 0x08) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_WERT", i, "8.2R");
              if (rc == FALSE) temp3=" ????   ";
              temp1 = temp1 + " " + temp3;
            }
            if ((_FsMode & 0x10) != 0)
            {
              INP1apiResultText(rc,temp3, "F_UW"+temp2+"_EINH", i, "");
              if (rc == FALSE) temp3="????";
              temp1 = temp1 + "  " + temp3;
            }
            filewrite( "   "+ temp1);
           }
         }
      }
    }
  }
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Umweltbedingungen
//*
//**********************************************************************
fs_protokoll_uwb_uds(in: int nr)
{
  int    i;
 // int    k;
//  int    len;
//  int    F_UW_ANZ;
  bool   rc;
  string temp1;
//  string temp2;
//  string temp3;
//  real   realval;
//  int    pos;

  i=nr;
  INP1apiResultText(rc,temp1, "F_UW_ZEIT", i, "10T");
  if (rc == FALSE)
  {
    temp1="     ????";
  }
  filewrite( "   Absolute Zeit                       " + temp1+ "     s");

  fs_protokoll_uwb(i);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Hexcode
//*
//**********************************************************************
fs_protokoll_hex(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;

  chr(10,nl);
  i=nr;
  filewrite( "");
  INP1apiResultBinary(rc,"F_HEX_CODE", i);
  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????";
  }
  filewrite( "Fehlercode: "+temp2);
}

//**********************************************************************
//*
//* Fehlerprotokollausgabe Telegrammantwort(en)
//* Wird nur bei Fehlerhaften FS_LESEN_DETAIL ausgegeben
//*
//**********************************************************************
fs_protokoll_telantwort(in: int nr)
{
  string nl;
  int    i;
  int    x1;
  int    x2;
  int    x3;
  bool   rc;
  string temp1;
  string temp2;
  string temp3;
  string temp4;
  string temp5;

  chr(10,nl);
  i=nr;
  filewrite( "");

  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_SNAPSHOT", i);
    else INP1apiResultBinary(rc,"_RESPONSE_2000", i);//IS_LESEN
  }
  else//1=DS2, 2=BMW Fast
  {
    INP1apiResultBinary(rc,"_TEL_ANTWORT", i);
  }


  if (rc == TRUE)
  {
    GetBinaryDataString (temp1, x1);
    x2 = 0;
    x3 = 0;
    temp2="";
    while ( x2 < x1 )
    {
      midstr(temp3, temp1, x2, 2);
      temp2 = temp2 + temp3;
      x2 = x2 + 2;
      x3 = x3 + 1;
      if ( x2 < x1 )
      {
        if ( x3 < 16 )//Leerzeichen zwischen den Bytes
        {
          if ( x3 == 8 )
            temp2 = temp2 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
          else temp2 = temp2 + " ";
        }
        else
        {
          x3 = 0;
          temp2 = temp2 + nl + "            ";
        }
      }
    }
  }
  else
  {
    temp2 = "????--> Zur Analyse IFH-Trace benutzen!";
  }

  //2. Telegramm nur für UDS ausgeben
  if (ident_typ == 3)//3=UDS (ISO 14229)
  {
    if (_ApiFsJobName == "FS_LESEN")
      INP1apiResultBinary(rc,"_RESPONSE_EXTENDED_DATA", i);
    else INP1apiResultBinary(rc,"_RESPONSE_200X", i);//IS_LESEN

    if (rc == TRUE)
    {
      GetBinaryDataString (temp1, x1);
      x2 = 0;
      x3 = 0;
      temp4="";
      while ( x2 < x1 )
       {
         midstr(temp3, temp1, x2, 2);
         temp4 = temp4 + temp3;
         x2 = x2 + 2;
         x3 = x3 + 1;
         if ( x2 < x1 )
         {
           if ( x3 < 16 )//Leerzeichen zwischen den Bytes
           {
             if ( x3 == 8 )
               temp4 = temp4 + "  ";//Nach 8 Bytes zwei Leerz. dann wieder 8 Bytes schreiben
             else temp4 = temp4 + " ";
           }
           else
           {
             x3 = 0;
             temp4 = temp4 + nl + "            ";
           }
         }
      }
    }
    else
    {
      temp4 = "????--> Zur Analyse IFH-Trace benutzen!";
    }

    filewrite("Telegramm-Antwort ab Service Identifier zur Analyse");
    if (_ApiFsJobName == "FS_LESEN")
    {
      filewrite("Data      : "+temp2);
      filewrite("Snapshot  : "+temp4);
    }
    else//IS_LESEN
    {
      filewrite("2000      : "+temp2);
      filewrite("200X      : "+temp4);
    }
  }
  else//DS2, BMW Fast
  {
  filewrite("Telegramm-");
  filewrite("Antwort   : "+temp2);
  }
}
// -- EOF --
// end of :#include "FS_LESEN.SRC"
// start of :#include "INITEXIT.SRC"
//**********************************************************************
//*
//* INPA Library-Funktionen INITEXIT.SRC
//*
//* mindestens INPA 5.0.1
//*
//**********************************************************************
//* Gall TI-430
//**********************************************************************
//* History:
//* 04.07.2000 rd V0.03 Ersterstellung
//* 25.04.2002 rd V1.00 Freigabe
//* 24.09.2002 rd V1.01 Scriptinit verlagert
//* 12.03.2003 iS V1.01 Anpassung SgbdInpaCheck()GroupCheck();
//* 16.02.2004 rd V2.00 Umstellung auf 32-Bit Version
//* 30.03.2006 GA V3.00 Erweiterung auf UDS (ISO 14229)
//*            GA V3.00 INPA.INI, [EXTRA], SRIPTS auslesen, ob "deleteread" gesetzt,
//*            GA V3.00 um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
//**********************************************************************

// **************************
// *** inpainit, inpaexit ***
// **************************
inpainit()
{
  bool   rc;
  string temp;
  int    i;

  INPAapiInit();
  chrinit();

  // Handle für FS_LESEN
  StrArrayCreate(rc,f_ort_nr_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_nr_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  StrArrayCreate(rc,f_ort_text_buffer);
  if (rc == FALSE)
  {
    messagebox("Unerwarteter Fehler", // sollte nie kommen
               "StrArrayCreate(rc,f_ort_text_buffer). "+CRLF+
               "Das Programm wird abgebrochen!");
    exit();
  }

  SgbdInpaCheck();
  GroupCheck();
  setmenu(m_main);
  setscreen(s_main,TRUE);

  //INPA.INI einlesen,
  //um nach FS- IS-, HS-Löschen automatisch wieder zu lesen.
  //hinter "SCRIPTS" muß DeleteRead stehen, um die Funktion freizuschalten
  ExtraScript("DeleteRead", deleteread_flag);

  //m FS,IS,HS zu speichern
  ExtraScript("SaveAs", fs_lesen_save_as_flag);
  is_lesen_save_as_flag=fs_lesen_save_as_flag;
  hs_lesen_save_as_flag=fs_lesen_save_as_flag;

  //INPA.INI-Einstellung, falls Funktionen gewünscht:
  //[EXTRA]
  //SCRIPTS               =  DeleteRead,SaveAs
  //Wichtig: Nach dem Komma kein Leerzeichen benutzen!

  ScriptInit();
}

inpaexit()
{
  INPAapiEnd();

  // Handle für FS_LESEN
  StrArrayDestroy(f_ort_nr_buffer);
  StrArrayDestroy(f_ort_text_buffer);
}

// -- EOF --
// end of :#include "INITEXIT.SRC"

// **************************
// *** Hauptmenü          ***
// **************************
MENU m_main()
{
  INIT  {
    setmenutitle("Hauptmenü");

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      setitem(2, "Ident", TRUE);
    }
    else
    {
      setitem(2, "SVK", TRUE);//ISO 14229
    }

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setitem( 4 , "Fehler"  , TRUE);
    }

    if (m_status_flag == TRUE)
    {
      setitem( 5 , "Status"  , TRUE);
    }

    if (m_steuern_flag == TRUE)
    {
      setitem( 6 , "Steuern"  , TRUE);
    }

    if (speicher_lesen_flag == TRUE)
    {
      setitem( 7 , "Speicher"  , TRUE);
    }
  }
  ITEM( 1 ,"Info")  {
    userboxclose(1);
    setscreen(s_info,TRUE);
  }
  ITEM( 2 ,"Ident")  {
    userboxclose(1);
    if (ident_typ == 1)
      setscreen(s_ident_ds2,TRUE);
    else if (ident_typ == 2)
      setscreen(s_ident,TRUE);
    else setscreen(s_svk_lesen,TRUE);
  }
  ITEM( 3 ,"")  {
    userboxclose(1);
    setscreen(s_main,TRUE);
  }
  ITEM( 4 ,"")  {
    userboxclose(1);
    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
    {
      setscreen( s_fehler ,TRUE);
      setmenu(m_fehler);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 5 ,"")  {
    userboxclose(1);
    if (m_status_flag == TRUE)
    {
      setscreen(s_status,TRUE);
      setmenu(m_status);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 6 ,"")  {
    userboxclose(1);
    if (m_steuern_flag == TRUE)
    {
      setscreen(s_steuern,TRUE);
      setmenu(m_steuern);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 7 ,"")  {
    userboxclose(1);
    if (speicher_lesen_flag == TRUE)
    {
      setscreen(s_speicher,TRUE);
      setmenu(m_speicher);
    }
    else
      setscreen( s_main ,TRUE);
  }
  ITEM( 8 ,"Auswahl")  {
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Ende")  {
    exit();
  }
  ITEM( 11,  "KVP") {
    setscreen(s_info,TRUE);
    callwin( "kvp_edit "+titel+";"+version+";"+sgbd+": "+sgbd_ecu+";"+sgbd_revision);
  }
  ITEM( 12 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 14 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 15 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_main ,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Fehlermenü         ***
// **************************
MENU m_fehler()
{
  int    ErrorCode;
  int    SpeicherUnterDateiNameLaenge=0;
  int    ReturnedValue;
  string CurrentDirectory;
  string SpeichernKommentar1="";
  string SpeichernKommentar2="";
  string SpeicherUnterDateiName="";
  string DateiLesenZeile="";
  string DateiLesenPuffer="";
  bool   DateiLesenEOF;
  string DateiName="";
  int    aufrufIO;
  string JOB_STATUS;
  bool   fehlerflag;

  INIT {
    setmenutitle("Fehlerspeicher");
    if (fs_lesen_flag == TRUE)
    {
      setitem( 1 , "FS lesen"    , TRUE);
      setitem( 2 , "FS löschen"  , TRUE);
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 3 , "IS lesen"    , TRUE);
      if (is_loeschen_flag == TRUE)
           setitem( 4 , "IS löschen"  , TRUE);
      else setitem( 4 , ""  , FALSE);//Nicht alle SGs haben IS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 5 , "HS lesen"    , TRUE);
      if (hs_loeschen_flag == TRUE)
           setitem( 6 , "HS löschen"  , TRUE);
      else setitem( 6 , ""  , FALSE);//Nicht alle SGs haben HS_LOESCHEN. Z.B. EPS_90.PRG

      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
  }
  ITEM( 1 ,"")  {
    userboxclose(0);
    viewclose();
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
      userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Fehlerspeicher lesen");
      setitem( 9 , "FS drucken"  , TRUE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
    }
  }
  ITEM( 2 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (fs_lesen_flag == TRUE)
    {
      INPAapiJob(sgbd,"FS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
        userboxftextout(0,"Der Fehlerspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Fehlerspeicher löschen","");
        userboxftextout(0,"Der Fehlerspeicher wurde gelöscht!",1,3,0,0);

        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPTS = DeleteRead
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Fehlerspeicher lesen","");
             userboxftextout(0,"Der Fehlerspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","",""); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Fehlerspeicher lesen");
             setitem( 9 , "FS drucken"  , TRUE);
             if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 3 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Infospeicher lesen","");
      userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Infospeicher lesen");
      setitem( 8 , "IS drucken"  , TRUE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
    }
  }
  ITEM( 4 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (is_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"IS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Infospeicher löschen","");
        userboxftextout(0,"Der Infospeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Infospeicher löschen","");
        userboxftextout(0,"Der Infospeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Infospeicher lesen","");
             userboxftextout(0,"Der Infospeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","IS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Infospeicher lesen");
             setitem( 8 , "IS drucken"  , TRUE);
             if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 5 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
      userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
      INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
      INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
      userboxclose(0);
      DateiName="na_fs.tmp";
      viewopen(DateiName,"Historienspeicher lesen");
      setitem( 7 , "HS drucken"  , TRUE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
    }
  }
  ITEM( 6 ,"")  {
    userboxclose(0);
    viewclose();
    if (fs_lesen_flag == TRUE)
    {
      setitem( 9 , "FS drucken"  , FALSE);
      if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
    }
    if (is_lesen_flag == TRUE)
    {
      setitem( 8 , "IS drucken"  , FALSE);
      if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
    }
    if (hs_lesen_flag == TRUE)
    {
      setitem( 7 , "HS drucken"  , FALSE);
      if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
    }
    if (hs_loeschen_flag == TRUE)
    {
      INPAapiJob(sgbd,"HS_LOESCHEN","","");
      INP1apiResultText(fehlerflag,JOB_STATUS, "JOB_STATUS", 1, "");
      if (JOB_STATUS != "OKAY")
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher konnte nicht gelöscht werden!",1,3,0,0);
        userboxsetcolor(0,1,4);
        INPAapiCheckJobStatus("OKAY");
      }
      else
      {
        userboxopen(0,8,35,5,50,"Historienspeicher löschen","");
        userboxftextout(0,"Der Historienspeicher wurde gelöscht!",1,3,0,0);
        if (deleteread_flag == TRUE) // Aktivierung über INPA.INI, SCRIPT = deleteread
           {
             delay(2000);
             userboxclose(0);
             userboxopen(0,8,35,5,50,"Historienspeicher lesen","");
             userboxftextout(0,"Der Historienspeicher wird gelesen! ... bitte warten",1,3,0,0);
             INPAapiFsMode_neu(0x7FF,"w","","","HS_LESEN"); // alles Anzeigen
             INPAapiFsLesen_neu(sgbd,"na_fs.tmp");
             userboxclose(0);
             DateiName="na_fs.tmp";
             viewopen(DateiName,"Historienspeicher lesen");
             setitem( 7 , "HS drucken"  , TRUE);
             if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", TRUE);
           }
      }
    }
  }
  ITEM( 7 ,"")  {
    if (hs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
    }
  }
  ITEM( 8 ,"")  {
    if (is_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 9 ,"")  {
    if (fs_lesen_flag == TRUE)
    {
      printfile(ErrorCode, DateiName, "", "",TRUE);
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(17 ,"")  {
    if ((hs_lesen_flag == TRUE) && (hs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Historienspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
      }
    }
  }
  ITEM(18 ,"")  {
    if ((is_lesen_flag == TRUE) && (is_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Infospeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
        if (fs_lesen_save_as_flag == TRUE) setitem(19 , "FS speichern", FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM(19 ,"")  {
    if ((fs_lesen_flag == TRUE) && (fs_lesen_save_as_flag == TRUE))
    {
      input2text(SpeichernKommentar1,SpeichernKommentar2,
      "Kommentar",
      "Geben Sie den zu speichernden Kommentar ein",
      "","");
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        space(SpeicherUnterDateiName,256);
        strlen(SpeicherUnterDateiNameLaenge,SpeicherUnterDateiName);

        GetCurrentDirectory(256,CurrentDirectory,ReturnedValue);
        SaveAsDialogBox("",SpeicherUnterDateiName,SpeicherUnterDateiNameLaenge,SpeicherUnterDateiNameLaenge);
        SetCurrentDirectory(CurrentDirectory,ReturnedValue);
        if (SpeicherUnterDateiNameLaenge > 0)
        {
          DateiLesenPuffer="";
          fileopen("na_fs.tmp","r");
          fileread(DateiLesenZeile, DateiLesenEOF );
          while (DateiLesenEOF == FALSE)
          {
            DateiLesenPuffer=DateiLesenPuffer+DateiLesenZeile;
            fileread(DateiLesenZeile, DateiLesenEOF );
            if (DateiLesenEOF == FALSE) DateiLesenPuffer=DateiLesenPuffer+LF;
          }
          fileclose();

          DateiName=SpeicherUnterDateiName;
          fileopen(DateiName,"w");
          if (SpeichernKommentar1 + SpeichernKommentar2 != "")
          {
            filewrite( "           K O M M E N T A R");
            filewrite( "           -----------------");
            filewrite( "");
            if (SpeichernKommentar1 != "") filewrite(SpeichernKommentar1);
            if (SpeichernKommentar2 != "") filewrite(SpeichernKommentar2);
            filewrite( "-------------------------------------------------------------");
            filewrite("");
          }
          filewrite(DateiLesenPuffer);
          fileclose();

          viewclose();
          viewopen(DateiName,"Fehlerspeicher speichern: "+DateiName);
        }
      }
    }
    else
    {
      userboxclose(0);
      viewclose();
      if (fs_lesen_flag == TRUE)
      {
        setitem( 9 , "FS drucken"  , FALSE);
      }
      if (is_lesen_flag == TRUE)
      {
        setitem( 8 , "IS drucken"  , FALSE);
        if (is_lesen_save_as_flag == TRUE) setitem(18 , "IS speichern", FALSE);
      }
      if (hs_lesen_flag == TRUE)
      {
        setitem( 7 , "HS drucken"  , FALSE);
        if (hs_lesen_save_as_flag == TRUE) setitem(17 , "HS speichern", FALSE);
      }
    }
  }
  ITEM( 10 ,"Zurück")  {
    userboxclose(0);
    viewclose();
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    userboxclose(0);
    viewclose();
    exit();
  }
}

// **************************
// *** Speichermenü       ***
// **************************
MENU m_speicher()
{
  int    input_ok=0;
  int    input_state;
  string text_var;

  INIT {
    setmenutitle("Speicher lesen");
    if (speicher_lesen_lar_flag==TRUE)    setitem( 1 , "LAR"  , TRUE);
    if (speicher_lesen_flash_flag==TRUE)  setitem( 2 , "FLASH", TRUE);
    if (speicher_lesen_uifm_flag==TRUE)   setitem( 3 , "UIFM" , TRUE);
    if (speicher_lesen_romi_flag==TRUE)   setitem( 4 , "ROMI" , TRUE);
    if (speicher_lesen_ramis_flag==TRUE)  setitem( 5 , "RAMIS", TRUE);
    if (speicher_lesen_ramil_flag==TRUE)  setitem( 6 , "RAMIL", TRUE);
    if (speicher_lesen_nvram_flag==TRUE)  setitem( 7 , "NVRAM", TRUE);
    if (speicher_lesen_romx_flag==TRUE)   setitem(14 , "ROMX" , TRUE);
    if (speicher_lesen_ramxx_flag==TRUE)  setitem(15 , "RAMXX", TRUE);
  }
  ITEM( 1 ,"")  {
    if (speicher_lesen_lar_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"LAR lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="LAR lesen";
        speicher_lesen_seg_adr_anz="LAR;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 2 ,"")  {
    if (speicher_lesen_flash_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"FLASH lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="FLASH lesen";
        speicher_lesen_seg_adr_anz="FLASH;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 3 ,"")  {
    if (speicher_lesen_uifm_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"UIFM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="UIFM lesen";
        speicher_lesen_seg_adr_anz="UIFM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 4 ,"")  {
    if (speicher_lesen_romi_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMI lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMI lesen";
        speicher_lesen_seg_adr_anz="ROMI;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 5 ,"")  {
    if (speicher_lesen_ramis_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIS lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIS lesen";
        speicher_lesen_seg_adr_anz="RAMIS;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 6 ,"")  {
    if (speicher_lesen_ramil_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMIL lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMIL lesen";
        speicher_lesen_seg_adr_anz="RAMIL;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 7 ,"")  {
    if (speicher_lesen_nvram_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"NVRAM lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="NVRAM lesen";
        speicher_lesen_seg_adr_anz="NVRAM;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 8 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 11 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 12 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 13 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 14 ,"")  {
    if (speicher_lesen_romx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"ROMX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="ROMX lesen";
        speicher_lesen_seg_adr_anz="ROMX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 15 ,"")  {
    if (speicher_lesen_ramxx_flag==TRUE)
    {
      input2hexnum(speicher_lesen_adresse,speicher_lesen_anzahl,"RAMXX lesen",
      "Es ist darauf zu achten, "+
      "daß die angegebene Adresse + Anzahl "+
      "der zu lesenden Bytes die Obergrenze "+
      "(FFFFFF) nicht überschreitet.",
      "Adresse 000000-FFFFFF","Anzahl der Bytes 1-200","000000","FFFFFF",1,200);
      getinputstate(input_state);
      if (input_state==input_ok)
      {
        speicher_lesen_text="RAMXX lesen";
        speicher_lesen_seg_adr_anz="RAMXX;"+speicher_lesen_adresse;
        inttostring(speicher_lesen_anzahl,text_var);
        speicher_lesen_seg_adr_anz=speicher_lesen_seg_adr_anz+";"+text_var;
        setscreen(s_speicher_ausgabe,TRUE);
      }
    }
    else
      setscreen(s_speicher,TRUE);
  }
  ITEM( 16 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 17 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 18 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 19 ,"")  {
    setscreen( s_speicher,TRUE);
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// *** Hauptscreen        ***
// **************************
SCREEN s_main()
{
  string text_var;

  userboxclose(0);
  ftextout("Hauptmenü",1,0,1,0);
  ftextout("",3,0,0,0);

  if (simulation_flag == TRUE)
  {
    userboxopen(1,14,30,5,48,"Hinweis","");
    userboxftextout(1,"INPA bzw. EDIABAS läuft im Simulationsmodus!",1,3,0,24);
    userboxsetcolor(1,0,4);
  }

  if (ident_typ != 3)
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");
  }

  LINE("","")
  {
    if (ident_typ != 3)//Nur bei DS2 und BMW Fast vorhanden
    {
      ftextout("BMW Teilenummer",1,0,0,0);
      ftextout(":",1,19,0,0);
      INPAapiResultText(text_var,"ID_BMW_NR",1,"");
      ftextout(text_var,1,20,0,1);

      ftextout("Herstelldatum",1,43,0,0);
      ftextout(":",1,59,0,0);
      if (ident_typ == 1)//DS2
      {
        ftextout("KW / Jahr",1,68,0,0);
        ftextout("/",1,63,0,1);
        INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
        ftextout(text_var,1,60,0,1);
        INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
        ftextout(text_var,1,65,0,1);
      }
      else if (ident_typ == 2)//BMW FAST
      {
        INPAapiResultText(text_var,"ID_DATUM",1,"");
        ftextout(text_var,1,60,0,1);
      }
    }

    ftextout("< F1 >  Information"              , 4,5,0,1);

    if ((ident_typ == 1)||(ident_typ == 2)) //DS2 oder BMW FAST
    {
      ftextout("< F2 >  Identifikation"           , 6,5,0,1);
    }
    else
    {
      ftextout("< F2 >  Steuergeräteverbaukennung"           , 6,5,0,1);//UDS (ISO 14229)
    }

    if ((fs_lesen_flag == TRUE) ||
        (is_lesen_flag == TRUE) ||
        (hs_lesen_flag == TRUE))
        ftextout("< F4 >  Fehlerspeicher"           ,10,5,0,1);

    if (m_status_flag == TRUE)
        ftextout("< F5 >  Status lesen"             ,12,5,0,1);

    if (m_steuern_flag == TRUE)
        ftextout("< F6 >  Ansteuern"                ,14,5,0,1);

    if (speicher_lesen_flag == TRUE)
        ftextout("< F7 >  Speicher lesen"           ,16,5,0,1);

    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F1 >  KVP-Editor"     , 4,45,0,1);
    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Infoscreen         ***
// **************************
SCREEN s_info ()
{
  int i;
  int slen;
  int pos;
  int pos2;
  int anzahl;
  string temp;

  ftextout("Information",1,0,1,0);
  ftextout("Nacharbeitsprogramm",4,0,0,0);             ftextout(":", 4,33,0,1); ftextout(titel,4,35,0,1);
  ftextout("Version",5,1,0,0);                         ftextout(":", 5,33,0,1); ftextout(version,5,35,0,1);
  ftextout("Package",6,1,0,0);                         ftextout(":", 6,33,0,1); ftextout(package,6,35,0,1);
  ftextout("Verantwortung",7,1,0,0);                   ftextout(":", 7,33,0,1); ftextout(origin,7,35,0,1);

  ftextout("Gruppendatei",10,0,0,0);                   ftextout(":",10,33,0,1); ftextout(gruppe,10,35,0,1);
  ftextout("Bezeichnung",11,1,0,0);                    ftextout(":",11,33,0,1); ftextout(gruppe_ecu,11,35,0,1);
  ftextout("Version",12,1,0,0);                        ftextout(":",12,33,0,1); ftextout(gruppe_revision,12,35,0,1);
  ftextout("Verantwortung",13,1,0,0);                  ftextout(":",13,33,0,1); ftextout(gruppe_origin,13,35,0,1);
  ftextout("Identifizierbare SGBD'en",14,1,0,0);

  strlen(slen, gruppe_comment);
  anzahl=44;
  pos=0;
  if ( slen <= anzahl )
  {
    ftextout(":",14,33,0,1); ftextout(gruppe_comment,14,35,0,1);
  }
  else
  {
    instr(pos2, anzahl, gruppe_comment, ",");
    if (pos2 > 0) anzahl=pos2+1;
    midstr(temp, gruppe_comment, pos, anzahl); ftextout(":",14,33,0,1); ftextout(temp,14,35,0,1);
    i=14;
    pos=pos+anzahl;
    while ( pos < slen )
    {
      i=i+1;
      anzahl=75;
      instr(pos2, pos + anzahl, gruppe_comment, ",");
      if (pos2 > 0) anzahl=pos2+1-pos;
      midstr(temp, gruppe_comment, pos, anzahl); ftextout(temp,i,1,0,1);
      pos=pos+anzahl;
      if ( i >= 18 )
      {
        if ( pos < slen ) ftextout(temp+" . . .",i,1,0,1);
        pos=slen;
      }
    }
  }

  ftextout("Steuergerätebeschreibungsdatei",21,0,0,0); ftextout(":",21,33,0,1); ftextout(sgbd,21,35,0,1);
  ftextout("Steuergerät",22,1,0,0);                    ftextout(":",22,33,0,1); ftextout(sgbd_ecu,22,35,0,1);
  ftextout("Version",23,1,0,0);                        ftextout(":",23,33,0,1); ftextout(sgbd_revision,23,35,0,1);
  ftextout("Package",24,1,0,0);                        ftextout(":",24,33,0,1); ftextout(sgbd_package,24,35,0,1);
  ftextout("Verantwortung",25,1,0,0);                  ftextout(":",25,33,0,1); ftextout(sgbd_origin,25,35,0,1);
  ftextout("Sprache",26,1,0,0);                        ftextout(":",26,33,0,1); ftextout(sgbd_sprache,26,35,0,1);
  if (sgbd_comment!="")
  {
    ftextout("Kommentar",27,1,0,0);
    ftextout(":",27,33,0,1);
    ftextout(sgbd_comment,27,35,0,1);
  }
}

// **************************
// *** Identscreen DS2    ***
// **************************
SCREEN s_ident_ds2()
{
  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"IDENT","","");
  INPAapiCheckJobStatus("OKAY");
  LINE("","")
  {
    ftextout("BMW Teilenummer",1,0,1,0);
    ftextout(":",1,33,1,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,35,1,1);

    ftextout("Hardwarenummer",4,0,1,0);
    ftextout(":",4,33,1,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,4,35,1,1);

    ftextout("Softwarenummer",7,0,1,0);
    ftextout(":",7,33,1,0);
    INPAapiResultText(text_var,"ID_SW_NR",1,"");
    ftextout(text_var,7,35,1,1);

    ftextout("Lieferant",10,0,1,0);
    ftextout(":",10,33,1,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,10,35,1,1);

    ftextout("Codier-Index",13,0,1,0);
    ftextout(":",13,33,1,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,13,35,1,1);

    ftextout("Diagnose-Index",16,0,1,0);
    ftextout(":",16,33,1,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,16,35,1,1);

    ftextout("Bus-Index",19,0,1,0);
    ftextout(":",19,33,1,0);
    INPAapiResultText(text_var,"ID_BUS_INDEX",1,"");
    ftextout(text_var,19,35,1,1);

    ftextout("Herstelldatum",22,0,1,0);
    ftextout(":",22,33,1,0);
    ftextout("KW / Jahr",22,55,1,0);
    ftextout("/",22,41,1,1);
    INPAapiResultText(text_var,"ID_DATUM_KW",1,"");
    ftextout(text_var,22,35,1,1);
    INPAapiResultText(text_var,"ID_DATUM_JAHR",1,"");
    ftextout(text_var,22,45,1,1);
  }
}

// ****************************
// *** Identscreen BMW Fast ***
// ****************************
SCREEN s_ident()
{
  string text_var;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext

  ftextout("Identifikation",1,0,1,0);
  ftextout("",3,0,0,1);

  LINE("Identifikation","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");

    ftextout("BMW Teilenummer",1,0,0,0);
    ftextout(":",1,43,0,0);
    INPAapiResultText(text_var,"ID_BMW_NR",1,"");
    ftextout(text_var,1,45,0,1);

    ftextout("Codier-Index",3,0,0,0);
    ftextout(":",3,43,0,0);
    INPAapiResultText(text_var,"ID_COD_INDEX",1,"");
    ftextout(text_var,3,45,0,1);

    ftextout("Varianten-Index",5,0,0,0);
    ftextout(":",5,43,0,0);
    INPAapiResultText(text_var,"ID_VAR_INDEX",1,"");
    ftextout(text_var,5,45,0,1);

    ftextout("Diagnose-Index",7,0,0,0);
    ftextout(":",7,43,0,0);
    INPAapiResultText(text_var,"ID_DIAG_INDEX",1,"");
    ftextout(text_var,7,45,0,1);

    ftextout("Hardwarenummer",9,0,0,0);
    ftextout(":",9,43,0,0);
    INPAapiResultText(text_var,"ID_HW_NR",1,"");
    ftextout(text_var,9,45,0,1);

    ftextout("Softwarenummer   Funktionssoftware",11,0,0,0);
    ftextout(":",11,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_FSV",1,"");
    ftextout(text_var,11,45,0,1);

    ftextout("Softwarenummer   Betriebssystem",13,0,0,0);
    ftextout(":",13,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_OSV",1,"");
    ftextout(text_var,13,45,0,1);

    ftextout("Softwarenummer   Nachrichtenkatalog",15,0,0,0);
    ftextout(":",15,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_MCV",1,"");
    ftextout(text_var,15,45,0,1);

    ftextout("Softwarenummer  (Reserve) Zur Zeit nicht benutzt",17,0,0,0);
    ftextout(":",17,43,0,0);
    INPAapiResultText(text_var,"ID_SW_NR_RES",1,"");
    ftextout(text_var,17,45,0,1);

    ftextout("Herstelldatum",19,0,0,0);
    ftextout(":",19,43,0,0);
    INPAapiResultText(text_var,"ID_DATUM",1,"");
    ftextout(text_var,19,45,0,1);

    ftextout("Lieferant",21,0,0,0);
    ftextout(":",21,43,0,0);
    INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
    ftextout(text_var,21,45,0,1);
  }
// *** AIF, Anwender-Information
// *** auf 2. Seite von IDENT

  LINE("Anwender-Information","")
  {
    INPAapiJob(sgbd,"AIF_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("",10,0,0,0);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Anwenderinfofeld (AIF_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: AIF_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      INPAapiResultInt(ganz_zahl,"AIF_ANZ_DATEN",1);
      if (ganz_zahl > 18)                // lange AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Datensatz Nr.",7,0,0,0);
        ftextout(":",7,43,0,0);
        INPAapiResultText(text_var,"AIF_SW_NR",1,"");
        ftextout(text_var,7,45,0,1);

        ftextout("Behörden Nr.",9,0,0,0);
        ftextout(":",9,43,0,0);
        INPAapiResultText(text_var,"AIF_BEHOERDEN_NR",1,"");
        ftextout(text_var,9,45,0,1);

        ftextout("Händler Nr.",11,0,0,0);
        ftextout(":",11,43,0,0);
        INPAapiResultText(text_var,"AIF_HAENDLER_NR",1,"");
        ftextout(text_var,11,45,0,1);

        ftextout("Tester Nr.",13,0,0,0);
        ftextout(":",13,43,0,0);
        INPAapiResultText(text_var,"AIF_SERIEN_NR",1,"");
        ftextout(text_var,13,45,0,1);

        ftextout("km-Stand",15,0,0,0);
        ftextout(":",15,43,0,0);
        INPAapiResultText(text_var,"AIF_KM",1,"");
        ftextout(text_var,15,45,0,1);

        ftextout("Programm-Stand",17,0,0,0);
        ftextout(":",17,43,0,0);
        INPAapiResultText(text_var,"AIF_PROG_NR",1,"");
        ftextout(text_var,17,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
      else                              //18 Byte -> kurze AIF ausgeben
      {
        ftextout("Fahrgestell Nr.",1,0,0,0);
        ftextout(":",1,43,0,0);
        INPAapiResultText(text_var,"AIF_FG_NR",1,"");
        ftextout(text_var,1,45,0,1);

        ftextout("Zusammenbau Nr.",3,0,0,0);
        ftextout(":",3,43,0,0);
        INPAapiResultText(text_var,"AIF_ZB_NR",1,"");
        ftextout(text_var,3,45,0,1);

        ftextout("Programmier-Datum",5,0,0,0);
        ftextout(":",5,43,0,0);
        INPAapiResultText(text_var,"AIF_DATUM",1,"");
        ftextout(text_var,5,45,0,1);

        ftextout("Adresse AIF",19,0,0,0);
        ftextout(":",19,43,0,0);
        INPAapiResultInt(ganz_zahl,"AIF_ADRESSE_LOW",1);
        inttohexstring(ganz_zahl,4,text_var);
        ftextout(text_var,19,45,0,1);

        ftextout("Anzahl freie AIF",21,0,0,0);
        ftextout(":",21,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_FREI",1,"");
        ftextout(text_var,21,45,0,1);

        ftextout("Anzahl Daten AIF",23,0,0,0);
        ftextout(":",23,43,0,0);
        INPAapiResultText(text_var,"AIF_ANZ_DATEN",1,"");
        ftextout(text_var,23,45,0,1);
      }
    }
  }

LINE("CFG Lesen","")
  {
    INPAapiJob(sgbd,"C_FG_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    ftextout("Codierdaten",0,0,0,1);
    ftextout("",10,0,0,0);// um auf einer neuen Seite darzustellen

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Fahrgestellnummer lesen (CFG_LESEN) vorhanden          " ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: C_FG_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Fahrgestell Nr.",3,0,0,0);
      ftextout(":",3,43,0,0);
      INPAapiResultText(text_var,"FG_NR",1,"");
      ftextout(text_var,3,45,0,1);
    }

    INPAapiJob(sgbd,"C_AEI_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);

    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Codierdatenänderungsindex (C_AEI_LESEN) vorhanden" ,3,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Codierdatenänderungsindex",6,0,0,0);
      ftextout(":",6,43,0,0);
      INPAapiResultText(text_var,"COD_AE_INDEX",1,"");
      ftextout(text_var,6,45,0,1);
    }
  }
}

// ****************************************************************************
// *** Identinformationen werden über SVK_LESEN ermittelt                   ***
// *** SVK: SteuergeräeVerbauKennung Soft- und Hardware für UDS (ISO 14229) ***
// ****************************************************************************
SCREEN s_svk_lesen()
{
  string text_var;
  string text_var2;
  int    ganz_zahl;
  string job_status="???";         // für Job_Statuskontrolle
  bool   fehlerflag;               // Fehlerflag
  int    sets;                     // Anzahl sets
  int    errorcode;                // EDIABAS Fehlernummer
  string errorcode_text;           // EDIABAS Fehlernummer
  string error_text;               // EDIABAS Fehlertext als Text
  bool   eingabeWeiter;
  int    input_state;              // Eingabestatus
  int    input_ok=1;               // Eingabe  mit Nein beendet
  int    i;
  int    offset;
  int    einheiten_anz;
  int    pos;
  real   realval;
  real   realval2;
  long   longval;
  long   rest_long;
  long   multiplik_long;

  ftextout("Steuergeräteverbaukennung Soft- und Hardware",1,0,1,0);
  ftextout("",2,0,0,1);
  LINE("Hersteller Information","")
  {//HERSTELLINFO_LESEN ist kein Pflichtjob! (Stand: 03.2006)
    INPAapiJob(sgbd,"HERSTELLINFO_LESEN","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Keine Herstellerinformationen vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else if (((fehlerflag == FALSE) && (errorcode != 98)) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: HERSTELLINFO_LESEN",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Herstelldatum",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultText(text_var,"ID_DATUM",1,"");
      ftextout(text_var,1,45,0,1);

      ftextout("Lieferant",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultText(text_var,"ID_LIEF_TEXT",1,"");
      ftextout(text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("Ident","")
  {
    INPAapiJob(sgbd,"IDENT","","");
    INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",1,"");
    INP1apiErrorCode(errorcode);
/*    if ((fehlerflag == FALSE) && (errorcode == 98))//98=SYS-0008: Job nicht gefunden
    {
      ftextout("Kein Ident vorhanden" ,1,0,0,0);
      ftextout("" ,2,0,0,0);
    }
    else */if (((fehlerflag == FALSE) /*&& (errorcode != 98)*/) || (job_status != "OKAY"))
    {
      ftextout("Fehler beim Lesen von Job: IDENT",1,0,0,0);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
      }
      else
      {
       error_text= "Job-Status-Fehlermeldung: "+job_status;
      }
      ftextout(error_text ,2,0,0,0);
      ftextout("" ,3,0,0,0);
      INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben
    }
    else
    {
      ftextout("Steuergeräte-Adresse",1,0,0,0);
      ftextout(":",1,41,0,0);
      INPAapiResultInt(ganz_zahl,"ID_SG_ADR",1);
      inttohexstring(ganz_zahl,4,text_var);
      //Führende Nullen ausblenden
      if (ganz_zahl <= 255) midstr(text_var,text_var,2,2);
      ftextout("0x"+text_var,1,45,0,1);

      ftextout("SGBD-Index",2,0,0,0);
      ftextout(":",2,41,0,0);
      INPAapiResultBinary("_RESPONSE",1);
      GetBinaryDataString (text_var,i);
      midstr(text_var,text_var,6,11);

      ftextout("0x"+text_var,2,45,0,1);
      ftextout("--------------------------------------------------------------------------------------------------------------------------------",3,0,0,0);
      ftextout("",4,0,0,0);
    }
  }

  LINE("SVK","")
  {
    INPAapiJob(sgbd,"SVK_LESEN","","");
    //INPAapiCheckJobStatus("OKAY"); //nicht anwendbar, da es mehrere Sets gibt und JOB_STATUS im letzten steht. Daher Fehlerausgabe manuell umsetzen
    sets=0;
    INP1apiResultSets(fehlerflag,sets);

    if ((fehlerflag == FALSE) || (sets <= 1))
    {
      ftextout("Fehler beim Lesen von Job: SVK_LESEN",1,0,0,0);
      INP1apiErrorCode(errorcode);
      if (errorcode != 0)
      {
        inttostring(errorcode, errorcode_text);
        INP1apiErrorText(error_text);
        error_text= "Ediabas-Fehlermeldung Nr.: "+errorcode_text+": "+ error_text;
        ftextout(error_text ,2,0,0,0);
        INPAapiResultSets(sets);//um Fehler auszugeben. Bsp.: IFH-0009: NO RESPONSE FROM CONTROLUNIT
      }
      else
      {//Nur möglich, da bei diesem Fehler der letzte Satz=1!
        INP1apiResultText(fehlerflag,job_status,"JOB_STATUS",sets,"");
        error_text= "Job-Status-Fehlermeldung: "+job_status;
        ftextout(error_text,2,0,0,0);
        INPAapiCheckJobStatus("OKAY");//um Fehler auszugeben. Bsp.: JOB_STATUS= ERROR_ECU_INCORRECT_LEN
      }
      ftextout("" ,3,0,0,0);
    }
    else
    {
      INPAapiResultText(text_var,"PROG_DATUM",sets,"");
      ftextout("Programm-Datum",0,0,0,0);
      ftextout(":",0,41,0,0);
      ftextout(text_var,0,45,0,1);

      INPAapiResultText(text_var,"PROG_KM",sets,"");
      if (text_var == "-1") text_var= "- - -";
      ftextout("Programm-km",1,0,0,0);
      ftextout(":",1,41,0,0);
      ftextout(text_var,1,45,0,1);

      INPAapiResultText(text_var,"ANZAHL_EINHEITEN",sets,"");
      INPAapiResultInt(einheiten_anz,"ANZAHL_EINHEITEN",sets);
      ftextout("Anzahl Prozeßklassen",2,0,0,0);
      ftextout(":",2,41,0,0);
      ftextout(text_var,2,45,0,1);

      ftextout("Prozeßklasse",5,2,0,1);
      ftextout("SGBM Identifier ",5,43,0,1);
      ftextout("Version",5,62,0,1);

      i=1;
      offset=0;
      while(i<=einheiten_anz)
      {
        inttostring(i,text_var2);
        INPAapiResultText(text_var,"PROZESSKLASSE_TEXT",i,"");
        ftextout(text_var2+") "+text_var,6+offset,0,0,0);

        //SGBM Identifier
        ftextout(":",6+offset,41,0,0);
        INPAapiResultText(text_var,"SGBM_IDENTIFIER",i,"");
        ftextout(text_var,6+offset,45,0,1);

        //Version
        INPAapiResultText(text_var,"VERSION",i,"");
        ftextout(text_var,6+offset,62,0,1);
        i=i+1;//um nächsten Set zu laden
        offset=offset+1;
      }
    }
  }
}

// **************************
// *** Speicherscreen     ***
// **************************
SCREEN s_speicher()
{
  ftextout("Speicher lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (speicher_lesen_lar_flag==TRUE)    ftextout("< F1 >  LAR lesen"               , 4,5,0,1);
    if (speicher_lesen_flash_flag==TRUE)  ftextout("< F2 >  FLASH lesen"             , 6,5,0,1);
    if (speicher_lesen_uifm_flag==TRUE)   ftextout("< F3 >  UIFM lesen"              , 8,5,0,1);
    if (speicher_lesen_romi_flag==TRUE)   ftextout("< F4 >  ROMI lesen"              ,10,5,0,1);
    if (speicher_lesen_ramis_flag==TRUE)  ftextout("< F5 >  RAMIS lesen"             ,12,5,0,1);
    if (speicher_lesen_ramil_flag==TRUE)  ftextout("< F6 >  RAMIL lesen"             ,14,5,0,1);
    if (speicher_lesen_nvram_flag==TRUE)  ftextout("< F7 >  NVRAM lesen"             ,16,5,0,1);
    if (speicher_lesen_romx_flag==TRUE)   ftextout("<Shift> + < F4 >  ROMX lesen"    ,10,45,0,1);
    if (speicher_lesen_ramxx_flag==TRUE)  ftextout("<Shift> + < F5 >  RAMXX lesen"   ,12,45,0,1);

    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Zurück"                   ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

// **************************
// *** Speicherscreen     ***
// *** Ausgabe            ***
// **************************
SCREEN s_speicher_ausgabe()
{
  string text_var;
  string job_state;

  ftextout(speicher_lesen_text,1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"SPEICHER_LESEN",speicher_lesen_seg_adr_anz,"");
  INPAapiResultText(job_state,"JOB_STATUS",1,"");
  LINE("","")
  {
    ftextout("Startadresse",1,0,0,0);
    ftextout(":",1,18,0,1);
    ftextout(speicher_lesen_adresse,1,20,0,1);
    ftextout("Anzahl",3,0,0,0);
    ftextout(":",3,18,0,1);
    inttostring(speicher_lesen_anzahl,text_var);
    ftextout(text_var,3,20,0,1);
    ftextout("Daten",5,0,0,0);
    ftextout(":",5,18,0,1);
    if(job_state != "OKAY")
      ftextout(job_state,5,20,0,1);
    else
    {
      INPAapiResultBinary("DATEN",1);
      hexdump(speicher_lesen_adresse,speicher_lesen_anzahl,5,20);
    }
  }
}

// **************************
// *** Fehlerscreen       ***
// **************************
SCREEN s_fehler()
{
  ftextout("Fehlerspeicher",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    if (fs_lesen_flag == TRUE)
    {
      ftextout("< F1 >  Fehlerspeicher lesen"      , 4,5,0,1);
      ftextout("< F2 >  Fehlerspeicher löschen"    , 6,5,0,1);
      ftextout("< F9 >  Fehlerspeicher drucken"    ,20,5,0,1);
      if (fs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F9 >  Fehlerspeicher speichern"   ,20,45,0,1);
    }

    if (is_lesen_flag == TRUE)
    {
      ftextout("< F3 >  Infospeicher lesen"        , 8,5,0,1);
      if (is_loeschen_flag == TRUE) ftextout("< F4 >  Infospeicher löschen"      ,10,5,0,1);
      ftextout("< F8 >  Infospeicher drucken"      ,18,5,0,1);
      if (is_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F8 >  Infospeicher speichern"     ,18,45,0,1);
    }

    if (hs_lesen_flag == TRUE)
    {
      ftextout("< F5 >  Historienspeicher lesen"   ,12,5,0,1);
      if (hs_loeschen_flag == TRUE) ftextout("< F6 >  Historienspeicher löschen" ,14,5,0,1);
      ftextout("< F7 >  Historienspeicher drucken" ,16,5,0,1);
      if (hs_lesen_save_as_flag == TRUE)
        ftextout("<Shift> + < F7 >  Historienspeicher speichern",16,45,0,1);
    }
    ftextout("< F10>  Zurück"                    ,22,5,0,1);
    ftextout("<Shift> + < F10>  Exit"            ,22,45,0,1);
  }
}
// -- EOF --
// end of :#include "bmw_std.src"

// ****************************************************
// ***             Initialisierungsfunktion         ***
// ****************************************************
ScriptInit()
{
  m_status_flag=TRUE;
  m_steuern_flag=TRUE;  
  settitle(titel+" Version "+version);
}





// ****************************************************
// ***             M e n ü a u f b a u              ***
// ****************************************************

// **************************
// *** Statusmenü         ***
// **************************

MENU m_status()
{
  INIT {
    setmenutitle("Status lesen");
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");
    INPAapiResultInt(int_diag,"ID_DIAG_INDEX",1);
    
  if (int_diag==0x0BC0) diag_index="E60X";
  if (int_diag==0x0BC1) diag_index="E90X_P";
  if (int_diag==0x0BC2) diag_index="E60X_P";
  if (int_diag==0x0BC3) diag_index="E60_P";
  if (int_diag==0x0BC4) diag_index="E60_P_AFS";
  if (int_diag==0x0BC5) diag_index="E70";
  if (int_diag==0x0BC6) diag_index="E90_China";
  if (int_diag==0x0D10) diag_index="E60_PP";
  if (int_diag==0x0D11) diag_index="E60X_PP";
     
  if ((diag_index =="E90X_P")||(diag_index =="E90_China")||(diag_index =="E70")) setitem( 6 , "SZL"  , TRUE);
       else setitem( 6 , "SZL"  , FALSE); }


  ITEM( 1 ,"Analog")  {
        setscreen( s_status_analog, TRUE);
        setmenu(m_status_analog);
  }
  ITEM( 2 ,"Digital")  {

    if ((diag_index=="E60X")||(diag_index=="E60X_P")||(diag_index=="E90X_P")||(diag_index=="E70"))  
        setscreen( s_status_digital_allrad ,TRUE);
        else setscreen( s_status_digital ,TRUE); 
  }


  ITEM( 3 , "RPA") {       
    setscreen( s_status_rpa_dsc,TRUE);
    setmenu(m_status_rpa);
  }

  ITEM( 4 ,"CBS")  {          
    if ((diag_index=="E90_China")||(diag_index=="E90X_P")||(diag_index=="E70")) 
        setscreen( s_status_cbs4 ,TRUE);            
        else setscreen( s_status_cbs ,TRUE);
  }

  ITEM( 5 ,"Id_Clust_SZL")  {
    if ((diag_index=="E90_China")||(diag_index=="E90X_P")||(diag_index=="E70"))     
        setscreen( s_status_szl_cluster ,TRUE);
        else setscreen( s_status_cluster ,TRUE);
  }


  ITEM( 6 ,"SZL")  {      
    setscreen( s_status_szl ,TRUE);
    setmenu(m_status_szl);
  }
        

  ITEM( 8 ,"Auswahl")  {
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}

// **************************
// ***  ENDE Statusmenü   ***
// **************************

// **************************
// *** Steuernmenü        ***   
// **************************
MENU m_steuern()
{
  INIT {
    setmenutitle("Steuern");
    INPAapiJob(sgbd,"IDENT","","");
    INPAapiCheckJobStatus("OKAY");
    INPAapiResultInt(int_diag,"ID_DIAG_INDEX",1);
  
  if (int_diag==0x0BC0) diag_index="E60X";
  if (int_diag==0x0BC1) diag_index="E90X_P";
  if (int_diag==0x0BC2) diag_index="E60X_P";
  if (int_diag==0x0BC3) diag_index="E60_P";
  if (int_diag==0x0BC4) diag_index="E60_P_AFS";
  if (int_diag==0x0BC5) diag_index="E70";
  if (int_diag==0x0BC6) diag_index="E90_China";
  if (int_diag==0x0D10) diag_index="E60_PP";
  if (int_diag==0x0D11) diag_index="E60X_PP"; 
     
  if ((diag_index =="E90X_P")||(diag_index =="E60X_P")||(diag_index =="E60X")||(diag_index =="E70")) setitem( 2 , "Kuppl_Test"  , TRUE);
       else setitem( 2 , "Kuppl_Test"  , FALSE); }
 
 ITEM( 1 ,"Entl.Rout.")  {                          
    setscreen( s_steuern_entl ,TRUE);
    setmenu(m_steuern_entl);
  }

 ITEM( 2 ,"Kuppl_Test")  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"STEUERN_KUPPLUNGS_TEST","R","");
    userboxftextout(0,"... bitte warten",1,3,0,0);
    INPAapiCheckJobStatus("OKAY");
    userboxclose(0);
    userboxopen(0,8,35,5,50,"X-Drive Test","");
    INPAapiResultText(text_var,"STAT_ERGEBNIS_BYTE_TEXT",1,"");
    userboxftextout(0,text_var,1,3,0,0);
    delay(2000);
    userboxclose(0);
    setscreen(s_steuern,TRUE);
  }
  
 ITEM( 3 ,"Laengsb.")  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"LAENGSBESCHLEUNIGUNG_DSC_ABGLEICHEN","","");
    userboxftextout(0,"... bitte warten",1,3,0,0);
    INPAapiCheckJobStatus("OKAY");
    userboxclose(0);
    userboxopen(0,8,35,5,50,"Abgleich Laengsbeschleunigung","");
    userboxftextout(0,"abgeschlossen",1,3,0,0);
    setscreen(s_steuern,TRUE);
  }
/* 
  ITEM( 4 ,"LWS")  {
    userboxclose(0);
    viewclose();
    INPAapiJob(sgbd,"LENKWINKEL_DSC_ABGLEICHEN","","");
    userboxftextout(0,"... bitte warten",1,3,0,0);
    INPAapiCheckJobStatus("OKAY");
    userboxclose(0);
    userboxopen(0,8,35,5,50,"Abgleich Lenkwinkel/Initialisierung FG-Nr.","");
    userboxftextout(0,"Initialisierung abgeschlossen",1,3,0,0);
    setscreen(s_steuern,TRUE);
  }
*/
  ITEM( 9 ,"Druck") {
    printscreen();
  } 
  ITEM( 10 , "Zurück") {
    setscreen(s_main, TRUE);
    setmenu(m_main);     
  }  
  ITEM( 20 ,"Exit") {
     exit();
  }
}

//************************************************************************************

MENU m_status_analog()
{
   INIT {
    setmenutitle("Status analog lesen");  
  }
  
 ITEM( 1 ,"v_Rad")  {
    setscreen( s_status_radgeschwindigkeit,  TRUE);
  }
  ITEM( 2 ,"Sensor")  {
    if (diag_index =="E60_P_AFS")setscreen( s_status_analog_afs ,TRUE);
        else setscreen( s_status_analog_dsc ,TRUE);
  }  
  ITEM( 3 ,"CAN")  {
    if ((diag_index =="E90X_P")||(diag_index =="E60X_P")||(diag_index =="E60X")||(diag_index =="E70")) setscreen( s_status_can_allrad ,TRUE);
       else setscreen( s_status_can ,TRUE);
  }
  ITEM( 4 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 5 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 6 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 7 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 8 ,"Auswahl")  {
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_status ,TRUE);
    setmenu( m_status );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}
//************************************************************************************

MENU m_status_rpa()
{
   INIT {
    setmenutitle("Status RPA");  
  }
 
 ITEM( 1 , "RPA Reset") {
    INPAapiJob(sgbd, "RPA_SCHREIBEN","01", "");      
    INPAapiCheckJobStatus("OKAY");
    userboxopen(0, 20,37,5,30,"RPA_SCHREIBEN","");                      
    userboxftextout(0,"RPA-Daten wurden geschrieben", 2,4,0,0);
    delay(3000);
    userboxclose(0);
   }    
  
  ITEM( 2 ,"Stat_RPA")  {
    setscreen( s_status_rpa ,TRUE);
   
  }  
  ITEM( 3 ,"RPA_FASTA")  {  
//   if ((diag_index=="E90_China")||(diag_index=="E90X_P")||(diag_index=="E70"))  
        setscreen( s_status_rpa_fasta ,TRUE);
//        else setscreen( s_status_rpa_e90x ,TRUE);
  }
  ITEM( 4 ,"RPA_LZ")  {
    setscreen( s_status_rpa_lernzaehler,TRUE);
  }
  ITEM( 5 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 6 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 7 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 8 ,"Auswahl")  {
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_status ,TRUE);
    setmenu( m_status );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}
//************************************************************************************

MENU m_status_szl()
{
   INIT {
    setmenutitle("Status SZL");  
  }

  ITEM( 1 ,"Audio")  {
    setscreen( s_status_audio_tel ,TRUE);   
  }   
  ITEM( 2 ,"Wischer")  {
    setscreen( s_status_wischer ,TRUE);   
  }  
  ITEM( 3 ,"Tempomat")  {
    setscreen( s_status_tempomat_acc ,TRUE);    
  }
  ITEM( 4 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 5 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 6 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 7 ,"")  {
    setscreen( s_status ,TRUE);
  }
  ITEM( 8 ,"Auswahl")  {
    start();
    select(TRUE);
  }
  ITEM(18 ,"Gesamt")  {
    start();
    deselect();
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    setscreen( s_status ,TRUE);
    setmenu( m_status );
  }
  ITEM( 20 ,"Exit")  {
    exit();
  }
}
//************************************************************************************

// **************************
// *** Steuernmenü DXC    ***  
// **************************
MENU m_steuern_entl()
{
  INIT {
    setmenutitle("Ventilansteuerung/Entlueftungsroutinen");

  }
 
  ITEM( 1, "Entl. HL")  {
  
    messagebox("Bremsen-Entlueftung","bitte Anweisungen genau befolgen !!!");
    messagebox("Bremsen-Entlueftung","Entluefterschrauben HL oeffnen");
 
     userboxopen(0,20,20,4,50,
    "Entlueftung Rad VR","  ");
    userboxftextout(0,
    "    "+"Die Routine dauert ca. 80 sec",1,0,0,1);
    userboxftextout(0,
    "    "+"Bremse_nicht_betaetigen",2,0,0,1);
    delay(3000);
        
    INPAapiJob(sgbd,"STEUERN_DX_STELLGLIED","E;ein;0;0;0;mra;ein;0;0;AVVL;AVVR;1000;aus;0;0;AVVL;AVVR;ein;0;0;0;EVHR;r","");
    delay(1000);
    i=0;
    while (i<=4) {
    INPAapiJob(sgbd,"STEUERN_DX_STELLGLIED","W;ein;0;0;0;VLV2;ein;0;0;0;USV2;3000;aus;0;0;0;VLV2;aus;0;0;0;USV2;r","");
    i=i+1;
    }
    
    delay(1000);                                                                           
    INPAapiJob(sgbd,"STEUERN_DX_STELLGLIED","W;aus;0;0;0;mra;ein;0;0;0;0;20;ein;0;0;0;0;aus;0;0;0;EVHR;r","");
    delay(2000);
    
    INPAapiJob(sgbd,"STEUERN_REP_ENTLUEFTUNG","E;H_links","");
    
    a=0;   
    text_var = "Funktion_noch_nicht_beendet";
     
    while ((text_var != "Funktion_beendet")&&(a==0)) {   // bei a=1 wurde Bremse nicht nicht ordnungsgemaess betätigt 
                                                           // die Schleife wird sofort verlassen
      INPAapiJob(sgbd,"STEUERN_ERGEBNIS_ROUTINE","REP_ENTLUEFTUNG","");
      INPAapiResultText(text_var,"STAT_ERGEBNIS_BYTE_TEXT",1,"");

      BLS_1();                 // Pruefung auf betaetigte Bremse
      delay(1000);
      
      BLS_0();                  // Pruefung auf geloeste Bremse
    }
    
  setcolor(1,0);    
  userboxclose(0);
  
  userboxopen(0,20,20,4,50,
  "Entlueftung Rad HL","  ");
  userboxftextout(0,
  "    "+"Ende der Entlueftungsroutine hinten links",1,0,0,1);
  delay(3000);
  userboxclose(0);
}   
  
  ITEM( 2, "Entl. VL")  {
  
    messagebox("Bremsen-Entlueftung","bitte Anweisungen genau befolgen !!!");
    messagebox("Bremsen-Entlueftung","Entluefterschrauben VL oeffnen");
           
    userboxopen(0,20,20,4,50,
    "Entlueftung Rad VL","  ");
    userboxftextout(0,
    "    "+"Die Routine dauert ca. 80 sec",1,0,0,1);
    userboxftextout(0,
    "    "+"Bremse_nicht_betaetigen",2,0,0,1);
    delay(3000);
        
    INPAapiJob(sgbd,"STEUERN_DX_STELLGLIED","E;ein;0;0;0;mra;ein;0;0;0;0;20;aus;0;0;0;0;ein;0;0;0;EVVR;r","");
    delay(1000);
    i=0;
    while (i<=4) {
    INPAapiJob(sgbd,"STEUERN_DX_STELLGLIED","W;ein;0;0;0;VLV1;ein;0;0;0;USV1;3000;aus;0;0;0;VLV1;aus;0;0;0;USV1;r","");
    i=i+1;
    }
    
    delay(1000);                                                                           
    INPAapiJob(sgbd,"STEUERN_DX_STELLGLIED","W;aus;0;0;0;mra;ein;0;0;0;0;20;ein;0;0;0;0;aus;0;0;0;EVVR;r","");
    delay(2000);
    
    INPAapiJob(sgbd,"STEUERN_REP_ENTLUEFTUNG","E;V_links","");
    
    a=0;   
    text_var = "Funktion_noch_nicht_beendet";
     
    while ((text_var != "Funktion_beendet")&&(a==0)) {

      INPAapiJob(sgbd,"STEUERN_ERGEBNIS_ROUTINE","REP_ENTLUEFTUNG","");
      INPAapiResultText(text_var,"STAT_ERGEBNIS_BYTE_TEXT",1,"");

      BLS_1();                 // Pruefung auf betaetigte Bremse
      delay(1000);
      
      BLS_0();                  // Pruefung auf geloeste Bremse
    }

  setcolor(1,0);    
  userboxclose(0);
  
  userboxopen(0,20,20,4,50,
  "Entlueftung Rad VL","  ");
  userboxftextout(0,
  "    "+"Ende der Entlueftungsroutine vorne links",1,0,0,1);
  delay(3000);
  userboxclose(0);
}   
  
  ITEM( 3, "Entl. VR")  {

   messagebox("Bremsen-Entlueftung","bitte Anweisungen genau befolgen !!!");
   messagebox("Bremsen-Entlueftung","Entluefterschrauben VR oeffnen");
           
    userboxopen(0,20,20,4,50,
    "Entlueftung Rad VR","  ");
    userboxftextout(0,
    "    "+"Die Routine dauert ca. 80 sec",1,0,0,1);
    userboxftextout(0,
    "    "+"Bremse_betaetigen",2,0,0,1);
    delay(3000);
    
    INPAapiJob(sgbd,"STEUERN_REP_ENTLUEFTUNG","E;V_rechts;3","");
    
    a=0;   
    text_var = "Funktion_noch_nicht_beendet";
     
    while ((text_var != "Funktion_beendet")&&(a==0)) {

      INPAapiJob(sgbd,"STEUERN_ERGEBNIS_ROUTINE","REP_ENTLUEFTUNG","");
      INPAapiResultText(text_var,"STAT_ERGEBNIS_BYTE_TEXT",1,"");

      BLS_1();                 // Pruefung auf betaetigte Bremse
      delay(1000);
      
      BLS_0();                  // Pruefung auf geloeste Bremse
      
    }

  setcolor(1,0);    
  userboxclose(0);
  
  userboxopen(0,20,20,4,50,
  "Entlueftung Rad HR","  ");
  userboxftextout(0,
  "    "+"Ende der Entlueftungsroutine vorne rechts",1,0,0,1);
  delay(3000);
  userboxclose(0);
}   

  
  ITEM( 4, "Entl. HR")  {

   messagebox("Bremsen-Entlueftung","bitte Anweisungen genau befolgen !!!");
   messagebox("Bremsen-Entlueftung","Entluefterschrauben HR oeffnen");
           
    userboxopen(0,20,20,4,50,
    "Entlueftung Rad HR","  ");
    userboxftextout(0,
    "    "+"Die Routine dauert ca. 80 sec",1,0,0,1);
    userboxftextout(0,
    "    "+"Bremse_betaetigen",2,0,0,1);
    delay(3000);
    
    INPAapiJob(sgbd,"STEUERN_REP_ENTLUEFTUNG","E;H_rechts;3","");
    
    a=0;   
    text_var = "Funktion_noch_nicht_beendet";
     
    while ((text_var != "Funktion_beendet")&&(a==0)) {

      INPAapiJob(sgbd,"STEUERN_ERGEBNIS_ROUTINE","REP_ENTLUEFTUNG","");
      INPAapiResultText(text_var,"STAT_ERGEBNIS_BYTE_TEXT",1,"");

      BLS_1();                 // Pruefung auf betaetigte Bremse
      delay(1000);
      
      BLS_0();                  // Pruefung auf geloeste Bremse
    }
   
  setcolor(1,0);    
  userboxclose(0);
  
  userboxopen(0,20,20,4,50,
  "Entlueftung Rad HR","  ");
  userboxftextout(0,
  "    "+"Ende der Entlueftungsroutine hinten rechts",1,0,0,1);
  delay(3000);
  userboxclose(0);
}   

  ITEM( 8 ,"")  {
    setscreen( s_steuern ,TRUE);
  }
  ITEM( 9 ,"Druck")  {
    printscreen();
  }
  ITEM( 10 ,"Zurück")  {
    userboxclose(0);
    setscreen( s_main ,TRUE);
    setmenu( m_main );
  }
  ITEM( 20 ,"Exit")  {
    userboxclose(0);
    exit();
  }
}




// ****************************************************
// ***             S c r e e n a u f b a u          ***
// ****************************************************

// **************************
// *** Statusscreen       ***
// **************************

SCREEN s_status()
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    ftextout("< F1 >  Analogeingänge"           , 4,5,0,1);
    ftextout("< F2 >  Digitale Ein-, Ausgänge"  , 6,5,0,1);
    ftextout("< F3 >  RPA"                        , 8,5,0,1);
    ftextout("< F4 >  CBS"                        ,10,5,0,1);     
    ftextout("< F5 >  Ident Sensor Cluster/SZL"   ,12,5,0,1);
        
  if ((diag_index =="E90X_P") || (diag_index =="E90_CHINA") || (diag_index =="E70")){
    ftextout("< F6 >  SZL"                        ,14,5,0,1);;
    }     
         
    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

//***************************************************************************************

SCREEN s_status_analog()
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    ftextout("< F1 >  Radgeschwindigkeit"       , 4,5,0,1);
    ftextout("< F2 >  Sensoren"                 , 6,5,0,1);
    ftextout("< F3 >  CAN"                        , 8,5,0,1);
 
    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

//***************************************************************************************

SCREEN s_status_rpa_dsc()
{
  ftextout("Status lesen RPA",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    ftextout("< F1 >  RPA Reset"                  , 4,5,0,1);
    ftextout("< F2 >  Status RPA"               , 6,5,0,1);
    ftextout("< F3 >  Status RPA FASTA"         , 8,5,0,1);
    ftextout("< F4 >  Status RPA LERNZAEHLER"   , 10,5,0,1);
 
    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

//***************************************************************************************

SCREEN s_status_szl()
{
  ftextout("Status lesen SZL",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("","")
  {
    ftextout("< F1 >  Taster Audio/Telefon"     , 4,5,0,1);
    ftextout("< F2 >  Wischertaster"            , 6,5,0,1);
    ftextout("< F3 >  Tempomat/ACC"             , 8,5,0,1);
        
    ftextout("< F8 >  Auswahl"                  ,18,5,0,1);
    ftextout("< F9 >  Bildschirmdruck"          ,20,5,0,1);
    ftextout("< F10>  Ende"                     ,22,5,0,1);

    ftextout("<Shift> + < F8 >  Gesamt"         ,18,45,0,1);
    ftextout("<Shift> + < F10>  Exit"           ,22,45,0,1);
  }
}

//***************************************************************************************





// ****************************************** 
// *** Statusscreen Radgeschwindigkeiten  ***
// ******************************************
SCREEN s_status_radgeschwindigkeit()
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_RADGESCHWINDIGKEIT","","");
  INPAapiCheckJobStatus("OKAY");

  LINE ( "Radgeschwindigkeiten, Drehrichtung", "")
  {
    ftextout("Radgeschwindigkeiten",1,0,1,0);
    
    INPAapiResultAnalog(zahlen_var,"STAT_RAD_GESCHW_VL_WERT",1);
    text(4,0,"vorne links");
    text(5,0,"[km/h]");
    analogout(zahlen_var*m_km, 6, 0, 0.0, 100.0 , 0.0, 100.0 , "3.1");

    INPAapiResultAnalog(zahlen_var,"STAT_RAD_GESCHW_VR_WERT",1);
    text(4,43,"vorne rechts");
    text(5,43,"[km/h]");
    analogout(zahlen_var*m_km, 6,43, 0.0, 100.0 , 0.0, 100.0 , "3.1");

    INPAapiResultAnalog(zahlen_var,"STAT_RAD_GESCHW_HL_WERT",1);
    text(9,0,"hinten links");
    text(10,0,"[km/h]");
    analogout(zahlen_var*m_km,11, 0, 0.0, 100.0 , 0.0, 100.0 , "3.1");

    INPAapiResultAnalog(zahlen_var,"STAT_RAD_GESCHW_HR_WERT",1);
    text(9,43,"hinten rechts");
    text(10,43,"[km/h]");
    analogout(zahlen_var*m_km,11,43, 0.0, 100.0 , 0.0, 100.0 , "3.1");
    
    INPAapiResultAnalog(zahlen_var,"STAT_RAD_GESCHW_REF_WERT",1);
    text(14,0,"Referenz");
    text(15,0,"[km/h]");
    analogout(zahlen_var*m_km,16,0, 0.0, 100.0 , 0.0, 100.0 , "3.1");
    
    ftextout("Drehrichtung",19,1,1,0);
    
    ftextout("VL:",22,1,0,0);
    INPAapiResultText(text_var,"STAT_DREHRICHTUNG_VL_TEXT",1,"");
    ftextout(text_var,22,5,0,0);
    
    ftextout("VR:",22,43,0,0);
    INPAapiResultText(text_var,"STAT_DREHRICHTUNG_VR_TEXT",1,"");
    ftextout(text_var,22,48,0,0);
    
    ftextout("HL:",24,1,0,0);
    INPAapiResultText(text_var,"STAT_DREHRICHTUNG_HL_TEXT",1,"");
    ftextout(text_var,24,5,0,0);
    
    ftextout("HR:",24,43,0,0);
    INPAapiResultText(text_var,"STAT_DREHRICHTUNG_HR_TEXT",1,"");
    ftextout(text_var,24,48,0,0);
  }
}

// ****************************************** 
// *** Statusscreen Analogwerte           ***
// ******************************************
SCREEN s_status_analog_dsc()
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_ANALOG","","");
  INPAapiCheckJobStatus("OKAY");


  LINE ( "DSC Drehrate_1", "DSC Querbeschleunigung_1")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_DREHRATE_WERT_1",1);
    text(1,0,"DSC Drehrate_1");
    text(2,0,"[Grad/sec]");
    multianalogout(zahlen_var, 3, 0, -90.0, 90.0 , -90.0, 90.0 , "3.2",1);
   
    INPAapiResultAnalog(zahlen_var,"STAT_QUERBESCHLEUNIGUNG_WERT_1",1);
    text(1,43,"DSC Querbeschleunigung_1");
    text(2,43,"[m/sec*sec]");
    multianalogout(zahlen_var, 3, 43, -10.0, 10.0 , -10.0, 10.0 , "3.2",1);
    }

  LINE ( "DSC Laengsbeschleunigung", "Bremsdruck" ) 
  {  
    INPAapiResultAnalog(zahlen_var,"STAT_DRUCK_WERT",1);
    text(1,43,"Bremsdruck");
    text(2,43,"[bar]");
    multianalogout(zahlen_var, 3, 43, -10.0, 200.0 , -10.0, 200.0 , "3.0",1);
      
    INPAapiResultAnalog(zahlen_var,"STAT_LAENGSBESCHLEUNIGUNG_WERT",1);
    text(1,0,"DSC Laengsbeschleunigung");
    text(2,0,"[m/sec*sec]");
    multianalogout(zahlen_var, 3, 0, -10.0, 10.0 , -10.0, 10.0 , "3.2",1);       
  }
  
  LINE ( "Bremsdruck_ACC_VA , Bremsdruck_ACC_HA", "")
   {
    INPAapiResultAnalog(zahlen_var,"STAT_DRUCK_WERT_ACC_VA",1);
    text(1,0,"Druck_ACC_VA");
    text(2,0,"[bar]");
    multianalogout(zahlen_var, 3, 0, -10.0, 200.0 , -10.0, 200.0 , "3.0",1);
    
    INPAapiResultAnalog(zahlen_var,"STAT_DRUCK_WERT_ACC_HA",1);
    text(1,43,"Druck_ACC_HA");
    text(2,43,"[bar]");
    multianalogout(zahlen_var, 3, 43, -10.0, 200.0 , -10.0, 200.0 , "2.1",1);  
  } 
   
  LINE ( "Ventilrelais, Pumpenmotor", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_VENTILRELAIS_SPANNUNG_WERT",1);
    text(1,0,"Spannung Ventilrelais");
    text(2,0,"[Volt]");
    analogout(zahlen_var, 3, 0, 0.0, 20.0 , 0.0, 20.0 , "2.1");
  
    INPAapiResultAnalog(zahlen_var,"STAT_PUMPENMOTOR_SPANNUNG_WERT",1);
    text(1,43,"Spannung Pumpenmotor");
    text(2,43,"[Volt]");
    analogout(zahlen_var, 3, 43, 0.0, 20.0 , 0.0, 20.0 , "2.1");   
  }
  LINE ( "Klemme 15", "")
  {    
    INPAapiResultAnalog(zahlen_var,"STAT_ZUENDUNG_WERT",1);
    text(1,0,"Klemme 15");
    text(2,0,"[Volt]");
    analogout(zahlen_var, 3, 0, 0.0, 20.0 , 0.0, 20.0 , "2.1");  
  }      
}


SCREEN s_status_analog_afs()  
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_ANALOG","","");
  INPAapiCheckJobStatus("OKAY");

  LINE ( "Summen-Lenkwinkel-AFS, Bremsdruck", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_SUMMEN_LENKWINKEL_WERT_AFS",1);
    text(1,0,"Summen-Lenkwinkel");
    text(2,0,"[Grad]");
    multianalogout(zahlen_var, 3, 0, -600.0, 600.0 , -600.0, 600.0 , "3.1",1);
    
    INPAapiResultAnalog(zahlen_var,"STAT_DRUCK_WERT",1);
    text(1,43,"Druck");
    text(2,43,"[bar]");
    multianalogout(zahlen_var, 3, 43, -10.0, 200.0 , -10.0, 200.0 , "3.0",1);       
  }
  LINE ( "Bremsdruck_ACC_VA , Bremsdruck_ACC_HA", "")
   {
    INPAapiResultAnalog(zahlen_var,"STAT_DRUCK_WERT_ACC_VA",1);
    text(1,0,"Druck_ACC_VA");
    text(2,0,"[bar]");
    multianalogout(zahlen_var, 3, 0, -10.0, 200.0 , -10.0, 200.0 , "3.0",1);
    
    INPAapiResultAnalog(zahlen_var,"STAT_DRUCK_WERT_ACC_HA",1);
    text(1,43,"Druck_ACC_HA");
    text(2,43,"[bar]");
    multianalogout(zahlen_var, 3, 43, -10.0, 200.0 , -10.0, 200.0 , "2.1",1);  
  }
  LINE ( "DSC Drehrate_1, AFS Drehrate_2", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_DREHRATE_WERT_1",1);
    text(1,0,"DSC Drehrate_1");
    text(2,0,"[Grad/sec]");
    multianalogout(zahlen_var, 3, 0, -90.0, 90.0 , -90.0, 90.0 , "3.2",1);
    
    INPAapiResultAnalog(zahlen_var,"STAT_DREHRATE_WERT_2",1);
    text(1,43,"AFS Drehrate_2");
    text(2,43,"[Grad/sec]");
    multianalogout(zahlen_var, 3, 43, -90.0, 90.0 , -90.0, 90.0 , "3.2",1); 
   }
  LINE ( "DSC Querbeschleunigung_1, AFS Querbeschleunigung_2", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_QUERBESCHLEUNIGUNG_WERT_1",1);
    text(1,0,"DSC Querbeschleunigung_1");
    text(2,0,"[m/sec*sec]");
    multianalogout(zahlen_var, 3, 0, -10.0, 10.0 , -10.0, 10.0 , "3.2",1);
    
    INPAapiResultAnalog(zahlen_var,"STAT_QUERBESCHLEUNIGUNG_WERT_2",1);
    text(1,43,"AFS Querbeschleunigung_2");
    text(2,43,"[m/sec*sec]");
    multianalogout(zahlen_var, 3, 43, -10.0, 10.0 , -10.0, 10.0 , "3.2",1);
    }  
  LINE ( "DSC Laengsbeschleunigung", "")
  {   
    INPAapiResultAnalog(zahlen_var,"STAT_LAENGSBESCHLEUNIGUNG_WERT",1);
    text(1,0,"DSC Laengsbeschleunigung");
    text(2,0,"[m/sec*sec]");
    multianalogout(zahlen_var, 3, 0, -10.0, 10.0 , -10.0, 10.0 , "3.2",1);
    }
  LINE ( "Ventilrelais, Pumpenmotor", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_VENTILRELAIS_SPANNUNG_WERT",1);
    text(1,0,"Spannung Ventilrelais");
    text(2,0,"[Volt]");
    analogout(zahlen_var, 3, 0, 0.0, 20.0 , 0.0, 20.0 , "2.1");
  
    INPAapiResultAnalog(zahlen_var,"STAT_PUMPENMOTOR_SPANNUNG_WERT",1);
    text(1,43,"Spannung Pumpenmotor");
    text(2,43,"[Volt]");
    analogout(zahlen_var, 3, 43, 0.0, 20.0 , 0.0, 20.0 , "2.1");   
  }
  LINE ( "Klemme 15", "")
  {    
    INPAapiResultAnalog(zahlen_var,"STAT_ZUENDUNG_WERT",1);
    text(1,0,"Klemme 15");
    text(2,0,"[Volt]");
    analogout(zahlen_var, 3, 0, 0.0, 20.0 , 0.0, 20.0 , "2.1");  
  }      
}



// ********************************************** 
// *** Statusscreen Digitale Ein-, Ausgaenge  ***
// **********************************************

SCREEN s_status_digital()
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_DIGITAL","","");
  INPAapiCheckJobStatus("OKAY");

  LINE ( "Bremslichtschalter", "")
  {
    ftextout("Bremslichtschalter",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_BREMSLICHT_SCHALTER_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
  
    LINE ( "DSC-Passiv Taster", "")
  {
    ftextout("DSC-Passivtaster",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_DSC_PASSIVTASTER_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Handbremsschalter", "")
  {
    ftextout("Handbremsschalter",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_HANDBREMSE_SCHALTER_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  }
  
  LINE ( "Bremsfluessigkeit_Niveau_OK", "")
  {
    ftextout("Bremsfluessigkeit_Niveau_OK",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_BREMSFLUESSIGKEIT_NIVEAU_SCHALTER_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
  
  LINE ( "Info Lampe", "")
  {
    ftextout("Info Lampe",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_INFO_LAMPE",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  }  
  
  LINE ( "DSC Passiv Lampe", "")
  {
    ftextout("DSC Passiv Lampe",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_DSC_PASSIVLAMPE",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  }
  
    LINE ( "ABS SILA", "")
  {
    ftextout("ABS SILA",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_ABS_SILA",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  }
  
  LINE ( "DSC SILA", "")
  {
    ftextout("DSC SILA",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_DSC_SILA",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  } 
  
  LINE ( "EDB SILA", "")
  {
    ftextout("EDB SILA",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EDB_SILA",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  } 
    
  LINE ( "Ventil Relais", "")
  {
    ftextout("Ventil Relais",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_VENTIL_RELAIS_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
  
  LINE ( "Pumpen Motor", "")
  {
    ftextout("Pumpen Motor",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_PUMPENMOTOR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
       
  LINE ( "Einlaß Ventil vorne links", "")
  {
    ftextout("Einlaß Ventil vorne links",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EVVL_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Auslaß Ventil vorne links", "")
  {
    ftextout("Auslaß Ventil vorne links",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_AVVL_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
 
  LINE ( "Einlaß Ventil vorne rechts", "")
  {
    ftextout("Einlaß Ventil vorne rechts",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EVVR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Auslaß Ventil vorne rechts", "")
  {
    ftextout("Auslaß Ventil vorne rechts",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_AVVR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Einlaß Ventil hinten links", "")
  {
    ftextout("Einlaß Ventil hinten links",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EVHL_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Auslaß Ventil hinten links", "")
  {
    ftextout("Auslaß Ventil hinten links",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_AVHL_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Einlaß Ventil hinten rechts", "")
  {
    ftextout("Einlaß Ventil hinten rechts",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EVHR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
   
  LINE ( "Auslaß Ventil hinten rechts", "")
  {
    ftextout("Auslaß Ventil hinten rechts",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_AVHR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Umschaltventil Vorderachse", "")
  {
    ftextout("Umschaltventil Vorderachse",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_UMSCHALTVENTIL_VORDERACHSE_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Umschaltventil Hinterachse", "")
  {
    ftextout("Umschaltventil Hinterachse",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_UMSCHALTVENTIL_HINTERACHSE_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Vorladeventil Vorderachse", "")
  {
    ftextout("Vorladeventil Vorderachse",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_VORLADEVENTIL_VORDERACHSE_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Vorladeventil Hinterachse", "")
  {
    ftextout("Vorladeventil Hinterachse",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_VORLADEVENTIL_HINTERACHSE_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
}


// ********************************************** 
// *** Statusscreen Digitale Ein-, Ausgaenge  ***
// **********************************************

SCREEN s_status_digital_allrad()
{
  ftextout("Status lesen",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_DIGITAL","","");
  INPAapiCheckJobStatus("OKAY");

  LINE ( "Bremslichtschalter", "")
  {
    ftextout("Bremslichtschalter",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_BREMSLICHT_SCHALTER_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
  
    LINE ( "DSC-Passiv Taster", "")
  {
    ftextout("DSC-Passivtaster",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_DSC_PASSIVTASTER_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

    LINE ( "Hill Descent Taster", "")
  {
    ftextout("Hill Descent Taster",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_HILLDESCENT_EIN",1); 
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
  
  LINE ( "Handbremsschalter", "")
  {
    ftextout("Handbremsschalter",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_HANDBREMSE_SCHALTER_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  }
  
  LINE ( "Bremsfluessigkeit_Niveau_OK", "")
  {
    ftextout("Bremsfluessigkeit_Niveau_OK",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_BREMSFLUESSIGKEIT_NIVEAU_SCHALTER_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
  
  LINE ( "Info Lampe", "")
  {
    ftextout("Info Lampe",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_INFO_LAMPE",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  }  
  
  LINE ( "DSC Passiv Lampe", "")
  {
    ftextout("DSC Passiv Lampe",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_DSC_PASSIVLAMPE",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  }
  
    LINE ( "ABS SILA", "")
  {
    ftextout("ABS SILA",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_ABS_SILA",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  }
  
  LINE ( "DSC SILA", "")
  {
    ftextout("DSC SILA",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_DSC_SILA",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  } 
  
  LINE ( "EDB SILA", "")
  {
    ftextout("EDB SILA",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EDB_SILA",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");    
  } 
    
  LINE ( "Ventil Relais", "")
  {
    ftextout("Ventil Relais",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_VENTIL_RELAIS_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
  
  LINE ( "Pumpen Motor", "")
  {
    ftextout("Pumpen Motor",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_PUMPENMOTOR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
       
  LINE ( "Einlaß Ventil vorne links", "")
  {
    ftextout("Einlaß Ventil vorne links",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EVVL_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Auslaß Ventil vorne links", "")
  {
    ftextout("Auslaß Ventil vorne links",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_AVVL_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
 
  LINE ( "Einlaß Ventil vorne rechts", "")
  {
    ftextout("Einlaß Ventil vorne rechts",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EVVR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Auslaß Ventil vorne rechts", "")
  {
    ftextout("Auslaß Ventil vorne rechts",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_AVVR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Einlaß Ventil hinten links", "")
  {
    ftextout("Einlaß Ventil hinten links",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EVHL_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Auslaß Ventil hinten links", "")
  {
    ftextout("Auslaß Ventil hinten links",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_AVHL_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Einlaß Ventil hinten rechts", "")
  {
    ftextout("Einlaß Ventil hinten rechts",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_EVHR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
   
  LINE ( "Auslaß Ventil hinten rechts", "")
  {
    ftextout("Auslaß Ventil hinten rechts",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_AVHR_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Umschaltventil Vorderachse", "")
  {
    ftextout("Umschaltventil Vorderachse",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_UMSCHALTVENTIL_VORDERACHSE_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Umschaltventil Hinterachse", "")
  {
    ftextout("Umschaltventil Hinterachse",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_UMSCHALTVENTIL_HINTERACHSE_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Vorladeventil Vorderachse", "")
  {
    ftextout("Vorladeventil Vorderachse",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_VORLADEVENTIL_VORDERACHSE_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }

  LINE ( "Vorladeventil Hinterachse", "")
  {
    ftextout("Vorladeventil Hinterachse",1,0,1,0);
    INPAapiResultDigital(logik_var,"STAT_VORLADEVENTIL_HINTERACHSE_EIN",1);
    digitalout(logik_var, 1,45,"EIN  ","AUS  ");
  }
}




// ****************************************** 
// *** Statusscreen CAN Signale           ***
// ******************************************
SCREEN s_status_can()
{
  ftextout("PT-CAN",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_CAN","","");
  INPAapiCheckJobStatus("OKAY");

  LINE ( "Lenkwinkel", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_LENKWINKEL_WERT",1);
    text(1,0,"Lenkwinkel Lenksaeule");
    text(2,0,"[Grad]");
    multianalogout(zahlen_var, 3, 0, -600,600, -600,600,  "3.1",1);
  }
  
    LINE ( "Motordrehzahl, Drehmonent", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_MOTORDREHZAHL_WERT",1);
    text(1,0,"Motordrehzahl");
    text(2,0,"[1/min]");
    analogout(zahlen_var, 3, 0, 0.0, 7000.0 , 0.0, 7000.0 , "3.1");
    
    INPAapiResultAnalog(zahlen_var,"STAT_DREHMOMENT_WERT",1);
    text(1,43,"Drehmonent");
    text(2,43,"[N/m]");
    multianalogout(zahlen_var, 3, 43, 0.0,6000, 0.0,6000,  "3.1",1);
  }
  
  LINE ( "Verzoegerungsanforderung", "")
  {   
    INPAapiResultAnalog(zahlen_var,"STAT_VERZOEGERUNGS_ANFORD_ACC_WERT",1);
    text(1,0,"Verzoegerungsanforderung:");
    text(2,0,"ACC");
    text(3,0,"[m/s*s]");
    multianalogout(zahlen_var, 4, 0, -20,20, -10,10,  "3.1",1);
    /*
    INPAapiResultAnalog(zahlen_var,"STAT_VERZOEGERUNGS_ANFORD_EMF_WERT",1);
    text(2,43,"EMF");
    text(3,43,"[m/s*s]");
    multianalogout(zahlen_var, 4, 43, -20,20, 0,10,  "3.1",1);
    */   
  }
}

SCREEN s_status_can_allrad()
{
  ftextout("PT-CAN",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_CAN","","");
  INPAapiCheckJobStatus("OKAY");

  LINE ( "Lenkwinkel", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_LENKWINKEL_WERT",1);
    text(1,0,"Lenkwinkel Lenksaeule");
    text(2,0,"[Grad]");
    multianalogout(zahlen_var, 3, 0, -600,600, -600,600,  "3.1",1);
  }
  
    LINE ( "Motordrehzahl, Drehmonent", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_MOTORDREHZAHL_WERT",1);
    text(1,0,"Motordrehzahl");
    text(2,0,"[1/min]");
    analogout(zahlen_var, 3, 0, 0.0, 7000.0 , 0.0, 7000.0 , "3.1");
    
    INPAapiResultAnalog(zahlen_var,"STAT_DREHMOMENT_WERT",1);
    text(1,43,"Drehmonent");
    text(2,43,"[N/m]");
    multianalogout(zahlen_var, 3, 43, 0.0,6000, 0.0,6000,  "3.1",1);
  }
  
  LINE ( "Verzoegerungsanforderung", "")
  {   
    INPAapiResultAnalog(zahlen_var,"STAT_VERZOEGERUNGS_ANFORD_ACC_WERT",1);
    text(1,0,"Verzoegerungsanforderung:");
    text(2,0,"ACC");
    text(3,0,"[m/s*s]");
    multianalogout(zahlen_var, 4, 0, -20,20, -10,10,  "3.1",1);
    /*
    INPAapiResultAnalog(zahlen_var,"STAT_VERZOEGERUNGS_ANFORD_EMF_WERT",1);
    text(2,43,"EMF");
    text(3,43,"[m/s*s]");
    multianalogout(zahlen_var, 4, 43, -20,20, 0,10,  "3.1",1);
    */   
  }
  
  LINE ( "Kupplung (MK_IST)", "")
  {
    INPAapiResultAnalog(zahlen_var,"STAT_KUPPLUNG_WERT",1);
    text(1,0,"Kupplungsmoment");
    text(2,0,"[Nm]");
    multianalogout(zahlen_var, 4, 0, -1100,1100, -1100,1100,  "3.1",1);
   } 
}

// ************************* 
// *** Statusscreen CBS  ***   
// *************************

SCREEN s_status_cbs()
{
  ftextout("CBS",1,0,1,0);
  ftextout("",3,0,0,0);                                                                                         
  INPAapiJob(sgbd,"CBS_DATEN_LESEN","","");
  INPAapiCheckJobStatus("OKAY");
  
// vorne 

    ftextout("VORNE",6,0,1,1);
    
    INPAapiResultAnalog(zahlen_var,"AVAI_BOS_WERT_BR_V",1);
    text(9,0,"Verfuegbarkeit vorne [%]");
    analogout(zahlen_var, 10, 0, 0.0, 100 , 0.0, 100 , "3.2");
  
    INPAapiResultInt(int_var,"ZIEL_MM_WERT",2);
    text(13,0,"Ziel-Monat (HU/AU)");
    inttostring(int_var,text_var);
    ftextout(text_var,14,0,0,1);    

    INPAapiResultInt(int_var,"ZIEL_YY_WERT",2);
    text(17,0,"Ziel-Jahr (HU/AU)");
    inttostring(int_var,text_var);
    ftextout(text_var,18,0,0,1);
                                                
    INPAapiResultAnalog(zahlen_var,"COU_RSTG_BOS_MESS_WERT",2);
    text(21,0,"Servicezaehler");
    analogout(zahlen_var, 22, 0, 0.0, 100 , 0.0, 100 , "3.0");

    INPAapiResultInt(int_var,"RMMI_BOS_WERT",2);
    text(25,0,"Restlaufleistung [km]");
    inttostring(int_var,text_var);
    ftextout(text_var, 26, 0, 0,1);    

//hinten

    ftextout("HINTEN",6,43,1,1);

    INPAapiResultAnalog(zahlen_var,"AVAI_BOS_WERT_BR_H",1);
    text(9,43,"Verfuegbarkeit hinten [%]");
    analogout(zahlen_var, 10, 43, 0.0, 100 , 0.0, 100 , "3.2");
    
    INPAapiResultInt(ganz_zahl,"ZIEL_MM_WERT",3);
    text(13,43,"Ziel-Monat (HU/AU)");
    inttostring(ganz_zahl,text_var);
    ftextout(text_var,14,43,0,1);    

    INPAapiResultInt(ganz_zahl,"ZIEL_YY_WERT",3);
    text(17,43,"Ziel-Jahr (HU/AU)");
    inttostring(ganz_zahl,text_var);
    ftextout(text_var,18,43,0,1);
  
    INPAapiResultAnalog(zahlen_var,"COU_RSTG_BOS_MESS_WERT",2);
    text(21,43,"Servicezaehler");
    analogout(zahlen_var,22, 43, 0.0, 100 , 0.0, 100 , "3.0");

    INPAapiResultInt(int_var,"RMMI_BOS_WERT",2);
    text(25,43,"Restlaufleistung [km]");
    inttostring(int_var,text_var);
    ftextout(text_var, 26, 43, 0,1);    
}




SCREEN s_status_cbs4()
{
  ftextout("CBS_4",1,0,1,0);
  ftextout("",3,0,0,0);                                                                                         
  INPAapiJob(sgbd,"CBS_DATEN_LESEN","","");
  INPAapiCheckJobStatus("OKAY");
  
// vorne 

    ftextout("Bremsbelag vorne",6,0,1,1);
    
    INPAapiResultAnalog(zahlen_var,"AVAI_CBS_WERT_BR_V",1);
    text(9,0,"Verfuegbarkeit vorne [%]");
    analogout(zahlen_var, 10, 0, 0.0, 100 , 0.0, 100 , "3.2");

    INPAapiResultInt(int_var,"COU_RSTG_CBS_MESS_WERT",2);
    text(13,0,"Servicezaehler:");
    inttostring(int_var,text_var);
    ftextout(text_var,13,25,0,1);
    
    INPAapiResultInt(int_var,"RMMI_CBS_WERT",2);
    text(16,0,"Restlaufleistung [km]:");
    inttostring(int_var,text_var);
    strcat(text_var,text_var,"0");
    ftextout(text_var, 16, 25, 0,1); 
    
    INPAapiResultInt(int_var,"FRC_INTM_WAY_CBS_MESS",2);
    text(19,0,"Prognose Wegintervall [km]:");
    inttostring(int_var,text_var);
    strcat(text_var,text_var,"000");
    ftextout(text_var, 19, 25, 0,1);
    
    text(22,0,"Manipulationsbyte:");
    INPAapiResultText(text_var,"MANIP_CBS_TEXT",2,"");
    ftextout(text_var,22,18,0,1);
    
        

//hinten

    ftextout("Bremsbelag hinten",6,43,1,1);

    INPAapiResultAnalog(zahlen_var,"AVAI_CBS_WERT_BR_H",1);
    text(9,43,"Verfuegbarkeit hinten [%]");
    analogout(zahlen_var, 10, 43, 0.0, 100 , 0.0, 100 , "3.2");

    INPAapiResultInt(int_var,"COU_RSTG_CBS_MESS_WERT",3);
    text(13,43,"Servicezaehler:");
    inttostring(int_var,text_var);
    ftextout(text_var,13,68,0,1);
    
    INPAapiResultInt(int_var,"RMMI_CBS_WERT",3);
    text(16,43,"Restlaufleistung [km]:");
    inttostring(int_var,text_var);
    strcat(text_var,text_var,"0");
    ftextout(text_var, 16, 68, 0,1); 
    
    INPAapiResultInt(int_var,"FRC_INTM_WAY_CBS_MESS",3);
    text(19,43,"Prognose Wegintervall [km]:");
    inttostring(int_var,text_var);
    strcat(text_var,text_var,"000");
    ftextout(text_var, 19, 68, 0,1);
   
    text(22,43,"Manipulationsbyte:");
    INPAapiResultText(text_var,"MANIP_CBS_TEXT",3,"");
    ftextout(text_var,22,61,0,1);
   
}




// ************************* 
// *** Statusscreen RPA  ***    
// *************************
SCREEN s_status_rpa_dsc_alt()
{
  ftextout("Status lesen RPA",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_RPA","","");
  INPAapiCheckJobStatus("OKAY");
 
  LINE("RPA-Status","") {
  ftextout("Aktiv =1 / Inaktiv =0",0,1,1,0);
  ftextout("Wegstrecke",4,1,0,0);
  ftextout(":",4,13,0,0);
  INPAapiResultText(text_var,"STAT_WEGSTRECKE",1,"");
  ftextout(text_var,4,14,0,1);
  
  text(7,p1,"Standardisierung"      );
  ftextout(":",7,13,0,0);
  INPAapiResultText(erg_text,"STAT_STANDARDISIERUNG_AKTIV",1,"");
  ftextout(erg_text,7,14,0,1);

  text(10,p1,"Reifenstatus"         );
  ftextout(":",10,13,0,0);
  INPAapiResultText(erg_text,"STAT_WARNUNG_AKTIV",1,"");
  ftextout(erg_text,10,14,0,1);
  
  text(13,p1,"Rejectionsphase"      );
  ftextout(":",13,13,0,0);
  INPAapiResultText(erg_text,"STAT_REJECTION_PHASE",1,"");
  ftextout(erg_text,13,14,0,1);
  
  text(16,p1,"Systemfunktion"        );
  ftextout(":",16,13,0,0);
  INPAapiResultText(erg_text,"STAT_SYSTEMFUNKTION_AKTIV",1,"");
  ftextout(erg_text,16,14,0,1);
  
  text(19,p1,"Blindphase"            );
  ftextout(":",19,13,0,0);
  INPAapiResultText(erg_text,"STAT_BLINDPHASE_AKTIV",1,"");
  ftextout(erg_text,19,14,0,1);
  
  text(21,p1,"Bremslichtschalter"                );
  ftextout(":",21,15,0,0);
  INPAapiResultText(erg_text,"STAT_BREMSLICHTSCHALTER_TEXT",1,"");
  ftextout(erg_text,21,16,0,1);
  }

  LINE("ABS-Rohsignale: [bar]","Standardisierung [bar]"){
  text(2,p1,"ABS-Rohsignale [Hz]");
  text(4, 1,vl); text(12,1,vr); text(8, 1,hl); text(16,1,hr);

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_VL" ,1);
  re=re*16;
  //re=3000.2;
  analogout(re, 5, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_VR" ,1);
  //re=2000.2;
  re=re*16;
  analogout(re,13, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_HL" ,1);
  //re=1000.2;
  re=re*16;
  analogout(re, 9, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_HR" ,1);
  //re=500.2;
  re=re*16;
  analogout(re,17, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  text(2,44,"Standardisierung [%]");
  text(5,44,"25 - 110 Km/h [%]");
  text(8,44,"110 - 135 Km/h [%]");
  text(11,44,"135 - 160 Km/h [%]");
  text(14,44,"160 - 185 Km/h [%]");
  text(17,44,"185 - 210 Km/h [%]");
  text(20,44," > 210 Km/h [%]");
  
  INPAapiResultAnalog(re,"STAT_BEREICH_0",1);
  //re=25;
  re=(re*100)/15;
  analogout(re, 3,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_1" ,1);
  //re=50;
  re=(re*100)/15;
  analogout(re, 6,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_2" ,1);
  //re=75;
  re=(re*100)/15;
  analogout(re, 9,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_3" ,1);
  //re=90;
  re=(re*100)/15;
  analogout(re,12,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_4" ,1);
  //re=100;
  re=(re*100)/15;
  analogout(re,15,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_5" ,1);
  //re=10;
  re=(re*100)/15;
  analogout(re,18,44, 0.0, 100, 33, 100, "1.0");
  
  INPAapiResultAnalog(re,"STAT_BEREICH_6" ,1);
  re=(re*100)/15;
  analogout(re,21,44, 0.0, 100, 33, 100, "1.0");
  }
}


// ************************* 
// *** Statusscreen RPA  ***    
// *************************
SCREEN s_status_rpa_dsc_70_alt()
{
  ftextout("Status lesen RPA",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_RPA","","");
  INPAapiCheckJobStatus("OKAY");
 
  LINE("RPA-Status","") {
  ftextout("Aktiv =1 / Inaktiv =0",0,1,1,0);
  ftextout("Wegstrecke",4,1,0,0);
  ftextout(":",4,13,0,0);
  INPAapiResultText(text_var,"STAT_WEGSTRECKE",1,"");
  ftextout(text_var,4,14,0,1);
  
  text(7,p1,"Standardisierung"      );
  ftextout(":",7,13,0,0);
  INPAapiResultText(erg_text,"STAT_STANDARDISIERUNG_AKTIV",1,"");
  ftextout(erg_text,7,14,0,1);

  text(10,p1,"Reifenstatus"         );
  ftextout(":",10,13,0,0);
  INPAapiResultText(erg_text,"STAT_WARNUNG_AKTIV",1,"");
  ftextout(erg_text,10,14,0,1);
  
  text(13,p1,"Rejectionsphase"      );
  ftextout(":",13,13,0,0);
  INPAapiResultText(erg_text,"STAT_REJECTION_PHASE",1,"");
  ftextout(erg_text,13,14,0,1);
  
  text(16,p1,"Systemfunktion"        );
  ftextout(":",16,13,0,0);
  INPAapiResultText(erg_text,"STAT_SYSTEMFUNKTION_AKTIV",1,"");
  ftextout(erg_text,16,14,0,1);
  
  text(19,p1,"Blindphase"            );
  ftextout(":",19,13,0,0);
  INPAapiResultText(erg_text,"STAT_BLINDPHASE_AKTIV",1,"");
  ftextout(erg_text,19,14,0,1);
  
  text(21,p1,"Bremslichtschalter"                );
  ftextout(":",21,15,0,0);
  INPAapiResultText(erg_text,"STAT_BREMSLICHTSCHALTER_TEXT",1,"");
  ftextout(erg_text,21,16,0,1);
  }

  LINE("ABS-Rohsignale: [bar]","Standardisierung [bar]"){
  text(2,p1,"ABS-Rohsignale [Hz]");
  text(4, 1,vl); text(12,1,vr); text(8, 1,hl); text(16,1,hr);

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_VL" ,1);
  re=re*16;
  //re=3000.2;
  analogout(re, 5, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_VR" ,1);
  //re=2000.2;
  re=re*16;
  analogout(re,13, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_HL" ,1);
  //re=1000.2;
  re=re*16;
  analogout(re, 9, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_HR" ,1);
  //re=500.2;
  re=re*16;
  analogout(re,17, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  text(2,44,"Standardisierung [%]");
  text(5,44,"25 - 110 Km/h [%]");
  text(8,44,"110 - 135 Km/h [%]");
  text(11,44,"135 - 160 Km/h [%]");
  text(14,44,"160 - 185 Km/h [%]");
  text(17,44,"185 - 210 Km/h [%]");
  text(20,44," > 210 Km/h [%]");
  
  INPAapiResultAnalog(re,"STAT_BEREICH_0",1);
  //re=25;
  re=(re*100)/15;
  analogout(re, 3,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_1" ,1);
  //re=50;
  re=(re*100)/15;
  analogout(re, 6,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_2" ,1);
  //re=75;
  re=(re*100)/15;
  analogout(re, 9,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_3" ,1);
  //re=90;
  re=(re*100)/15;
  analogout(re,12,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_4" ,1);
  //re=100;
  re=(re*100)/15;
  analogout(re,15,44, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_5" ,1);
  //re=10;
  re=(re*100)/15;
  analogout(re,18,44, 0.0, 100, 33, 100, "1.0");
  
  INPAapiResultAnalog(re,"STAT_BEREICH_6" ,1);
  re=(re*100)/15;
  analogout(re,21,44, 0.0, 100, 33, 100, "1.0");
  }
}


// ************************************* 
// *** Statusscreen RPA FASTA Daten  ***   
// *************************************

SCREEN s_status_rpa_fasta()
{
  ftextout("Status lesen FASTA-Daten",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_RPA_FASTA","","");
  INPAapiCheckJobStatus("OKAY");
  
    LINE("Standardisierung","")
    {
    ftextout("Standardisierung",2,0,1,1);
    
    ftextout("km-Stand bei letzter Standardisierung:",5,1,0,0);
    INPAapiResultText(text_var,"STAT_KM_LETZTE_STANDARDISIERUNG",1,"");
    ftextout(text_var,5,32,0,1);
    
    ftextout("km-Stand 3PLUS1_Erkennung:",7,1,0,0);
    INPAapiResultText(text_var,"STAT_KM_STAND_3PLUS1_ERKENNUNG_NACH_STANDARDISIERUNG",1,"");
    ftextout(text_var,7,32,0,1);
    
    ftextout("km-Stand Neureifen Erkennung:",9,1,0,0);
    INPAapiResultText(text_var,"STAT_KM_STAND_NEUREIFEN_ERKENNUNG_NACH_STANDARDISIERUNG",1,"");
    ftextout(text_var,9,32,0,1);
    
        if (diag_index =="E70"){      
 
        ftextout("Position Neureifen:",11,1,0,0);
        INPAapiResultText(text_var,"STAT_NEW_TYRE_POSITON_TEXT",1,"");
        ftextout(text_var,11,32,0,1);
        }
        else {
    
        ftextout("Position Neureifen:",11,1,0,0);
        INPAapiResultText(text_var,"STAT_POSITON_NEUREIFEN",1,"");
        ftextout(text_var,11,32,0,1);
        }       
    }
   
    LINE("Panne","")
    {
    ftextout("Panne",6,0,1,1);             
 
    ftextout("km-Stand bei letzter Panne",12,1,1,0);
    ftextout(":",12,56,1,0);
    INPAapiResultText(text_var,"STAT_KM_LETZTE_PANNE",1,"");
    ftextout(text_var,12,58,1,1);

    ftextout("km-Stand bei vorletzter Panne",15,1,1,0);
    ftextout(":",15,56,1,0);
    INPAapiResultText(text_var,"STAT_KM_VORLETZTE_PANNE",1,"");
    ftextout(text_var,15,58,1,1);                 
    }

    LINE("Gesamtstrecke","")
    {
    ftextout("Gesamtwegstrecke [km]",6,0,1,1);
    
    ftextout("Gesamtwegstrecke waehrend letzter Panne:",12,1,1,0);
//    ftextout(":",9,68,1,0);
    INPAapiResultText(text_var,"STAT_WEG_LETZTE_PANNE",1,"");
    ftextout(text_var,12,70,1,1);

// NEU 19.01.04 AB       
//    INPAapiResultText(text_var,"STAT_WEG_LETZTE_PANNE_TEXT",1,"");
//    ftextout(text_var,12,1,1,1); 

    ftextout("Gesamtwegstrecke waehrend vorletzter Panne:",15,1,1,0);
//    ftextout(":",16,68,1,0);
    INPAapiResultText(text_var,"STAT_WEG_VORLETZTE_PANNE",1,"");
    ftextout(text_var,15,70,1,1);       
    
// NEU 19.01.04 AB             
//    INPAapiResultText(text_var,"STAT_WEG_VORLETZTE_PANNE_TEXT",1,"");
//    ftextout(text_var,19,1,1,1);      
    }
   
    LINE("Geschwindigkeit","")
    {
    ftextout("Geschwindigkeit [km/h]",7,0,1,1);
/*
    ftextout("Geschwindigkeitsindikator",9,1,1,0);
    ftextout(":",9,68,1,0);
    INPAapiResultText(text_var,"STAT_GESCHWINDIGKEIT_INDIK",1,"");
    ftextout(text_var,9,70,1,1);
 */   
    ftextout("Geschwindigkeit waehrend letzter Panne",12,1,1,0);
    ftextout(":",12,68,1,0);
    INPAapiResultText(text_var,"STAT_GESCHWINDIGKEIT_LETZTE_PANNE",1,"");
    ftextout(text_var,12,70,1,1);

    ftextout("Geschwindigkeit waehrend vorletzter Panne",15,1,1,0);
    ftextout(":",15,68,1,0);
    INPAapiResultText(text_var,"STAT_GESCHWINDIGKEIT_VORLETZTE_PANNE",1,"");
    ftextout(text_var,15,70,1,1);    

    ftextout("Max. Geschwindigkeit waehrend letzter Panne",18,1,1,0);
    ftextout(":",18,68,1,0);
    INPAapiResultText(text_var,"STAT_GESCHWINDIGKEIT_MAX_LETZTE_PANNE",1,"");
    ftextout(text_var,18,70,1,1);

    ftextout("Max. Geschwindigkeit waehrend vorletzter Panne",21,1,1,0);
    ftextout(":",21,68,1,0);
    INPAapiResultText(text_var,"STAT_GESCHWINDIGKEIT_MAX_VORLETZTE_PANNE",1,"");
    ftextout(text_var,21,70,1,1);        
    }
    
    LINE("Anzahl Tage","")
    {
    ftextout("Anzahl Tage",2,0,1,1);
    
    ftextout("Anzahl Tage gemessen seit letztem",5,1,1,0);
    ftextout("Standardisierungsstart",7,1,1,0);
    ftextout(":",7,60,1,0);
    INPAapiResultText(text_var,"STAT_TAGE_SEIT_STANDARDISIERUNG",1,"");
    ftextout(text_var,7,62,1,1);
 
    ftextout("Anzahl Tage gemessen zwischen letztem",10,1,1,0);
    ftextout("Standardisierungsstart und Panne danach",12,1,1,0);    
    ftextout(":",12,60,1,0);
    INPAapiResultText(text_var,"STAT_TAGE_SEIT_LETZTER_PANNE",1,"");
    ftextout(text_var,12,62,1,1);  
    
    ftextout("Anzahl Tage gemessen zwischen letzter/vorletzter Panne",15,1,1,0);
    ftextout("und Standardisierungsstart danach",17,1,1,0);
    ftextout(":",17,60,1,0);
    INPAapiResultText(text_var,"STAT_TAGE_SEIT_VORLETZTER_PANNE",1,"");
    ftextout(text_var,17,62,1,1);         
    }    

    LINE("RPA-Version","")
    {
    ftextout("RPA-Version",6,0,1,1);
    
    ftextout("aktuelle RPA Versionsnummer",9,1,1,0);
    ftextout(":",9,56,1,0);
    INPAapiResultText(text_var,"STAT_RPA_REV_ACTUAL",1,"");
    ftextout(text_var,9,58,1,1);
 
    ftextout("RPA Versionsnummer",14,1,1,0);
    ftextout("zum Zeitpunkt der letzten Codierung",17,1,1,0);
    ftextout(":",17,56,1,0);
    INPAapiResultText(text_var,"STAT_RPA_REV_AT_LASTCODING",1,"");
    ftextout(text_var,17,58,1,1);      
    }    

}


// ****************************************** 
// *** Statusscreen RPA LERNZAEHLERSTAND  ***   
// ******************************************

SCREEN s_status_rpa_lernzaehler()
{
    ftextout("Status lesen RPA-Lernzaehler",1,0,1,0);
    ftextout("",3,0,0,0);
    INPAapiJob(sgbd,"STATUS_RPA_STANDARDISIERUNG_3","","");
    INPAapiCheckJobStatus("OKAY");
    
    LINE("Lernzaehlerstand","")
    {   
//    ftextout("Lernzaehlerstand",3,0,1,1);
    
    ftextout("Lernzaehlerstand 1",9,1,1,0);
    ftextout(":",9,56,1,0);
    INPAapiResultText(text_var,"STAT_L1",1,"");
    ftextout(text_var,9,58,1,1);
    
    ftextout("Lernzaehlerstand 2",12,1,1,0);
    ftextout(":",12,56,1,0);
    INPAapiResultText(text_var,"STAT_L2",1,"");
    ftextout(text_var,12,58,1,1);
    
    ftextout("Lernzaehlerstand 3",15,1,1,0);
    ftextout(":",15,56,1,0);
    INPAapiResultText(text_var,"STAT_L3",1,"");
    ftextout(text_var,15,58,1,1);       
    }
  
  LINE("Standardisierung","")  
  {
  text(2,1,"Bereich_0");
  text(5,1,"Bereich_1");
  text(8,1,"Bereich_2");
  text(11,1,"Bereich_3");
  text(14,1,"Bereich_4");
  text(17,1,"Bereich_5");
  text(20,1,"Bereich_6");
  text(2,15,"Standardisierung [%]");
  text(5,15,"25 - 110 km/h [%]");
  text(8,15,"110 - 135 km/h [%]");
  text(11,15,"135 - 160 km/h [%]");
  text(14,15,"160 - 185 km/h [%]");
  text(17,15,"185 - 210 km/h [%]");
  text(20,15," > 210 km/h [%]");
  
  INPAapiResultAnalog(re,"STAT_BEREICH_0",1);
  //re=25;
  re=(re*100)/150;
  analogout(re, 3,15, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_1" ,1);
  //re=50;
  re=(re*100)/900;
  analogout(re, 6,15, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_2" ,1);
  //re=75;
  re=(re*100)/240;
  analogout(re, 9,15, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_3" ,1);
  //re=90;
  re=(re*100)/240;
  analogout(re,12,15, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_4" ,1);
  //re=100;
  re=(re*100)/240;
  analogout(re,15,15, 0.0, 100, 33, 100, "1.0");

  INPAapiResultAnalog(re,"STAT_BEREICH_5" ,1);
  //re=10;
  re=(re*100)/240;
  analogout(re,18,15, 0.0, 100, 33, 100, "1.0");
  
  INPAapiResultAnalog(re,"STAT_BEREICH_6" ,1);
  re=(re*100)/240;
  analogout(re,21,15, 0.0, 100, 33, 100, "1.0");
  }
}

  // ************************* 
  // *** Statusscreen RPA  ***    
  // *************************

SCREEN s_status_rpa()
{
  ftextout("Status lesen RPA",1,0,1,0);
  ftextout("",3,0,0,0);
  INPAapiJob(sgbd,"STATUS_RPA","","");
  INPAapiCheckJobStatus("OKAY");
 
  LINE("RPA-Status","") {

  ftextout("Aktiv =1 / Inaktiv =0",0,1,1,0);

  ftextout("Wegstrecke",4,1,0,0);
  ftextout(":",4,15,0,0);
  INPAapiResultText(text_var,"STAT_WEGSTRECKE",1,"");
  ftextout(text_var,4,17,0,1);
  
  text(7,p1,"Standardisierung"      );
  ftextout(":",7,15,0,0);
  INPAapiResultText(erg_text,"STAT_STANDARDISIERUNG_AKTIV",1,"");
  ftextout(erg_text,7,17,0,1);

  text(10,p1,"Reifenstatus"         );
  ftextout(":",10,15,0,0);
  INPAapiResultText(erg_text,"STAT_WARNUNG_AKTIV",1,"");
  ftextout(erg_text,10,17,0,1);
  
  text(13,p1,"Rejectionsphase"      );
  ftextout(":",13,15,0,0);
  INPAapiResultText(erg_text,"STAT_REJECTION_PHASE",1,"");
  ftextout(erg_text,13,17,0,1);
  
  text(16,p1,"Systemfunktion"        );
  ftextout(":",16,15,0,0);
  INPAapiResultText(erg_text,"STAT_SYSTEMFUNKTION_AKTIV",1,"");
  ftextout(erg_text,16,17,0,1);
  
  text(19,p1,"Blindphase"            );
  ftextout(":",19,15,0,0);
  INPAapiResultText(erg_text,"STAT_BLINDPHASE_AKTIV",1,"");
  ftextout(erg_text,19,17,0,1);
  
  text(21,p1,"Bremslichtschalter"                );
  ftextout(":",21,15,0,0);
  INPAapiResultText(erg_text,"STAT_BREMSLICHTSCHALTER_TEXT",1,"");
  ftextout(erg_text,21,17,0,1);
  }

  LINE("ABS-Rohsignale: [bar]","Standardisierung [bar]"){
  text(2,p1,"ABS-Rohsignale [Hz]");
  text(4, 1,vl); text(4,45,vr); text(8, 1,hl); text(8,45,hr);

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_VL" ,1);
  re=re*16;
  //re=3000.2;
  analogout(re, 5, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_VR" ,1);
  //re=2000.2;
  re=re*16;
  analogout(re,5, 45, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_HL" ,1);
  //re=1000.2;
  re=re*16;
  analogout(re, 9, 1, 0.0, 2000, 0.0, 2000.0, "1.0");

  INPAapiResultAnalog(re,"STAT_DSC_SIGNAL_HR" ,1);
  //re=500.2;
  re=re*16;
  analogout(re,9, 45, 0.0, 2000, 0.0, 2000.0, "1.0");
     
  if ((diag_index =="E60_PP")||(diag_index =="E60X_PP")||(diag_index =="E70")){ 
  
        ftextout("Position Pannenreifen:",21,1,1,0);
        INPAapiResultText(text_var,"STAT_DEFLATION_POSITON_TEXT",1,"");
        ftextout(text_var,21,35,1,1);
        }
  
  }
}




// ********************************************
// *** Statusscreen Ident SZL/Sensorcluster  ***
// ********************************************

 SCREEN s_status_szl_cluster()

{
  ftextout("Ident SZL/Sensorcluster",1,0,1,0);
  ftextout("",3,0,0,0);

  INPAapiCheckJobStatus("OKAY");

  LINE ( "Anzahl Subbusteilnehmer", "")
  {
    INPAapiJob(sgbd,"SENSOREN_ANZAHL_LESEN","","");
    
    ftextout("Anzahl Subbusteilnehmer:",1,0,1,0);
    INPAapiResultText(text_var,"SENSOR_ANZAHL",1,"");
    ftextout(text_var,1,40,1,1);   
  }

  LINE ( "Ident SZL/Sensorcluster", "")
  {
    INPAapiJob(sgbd,"SENSOREN_IDENT_LESEN","","");

    ftextout("Ident SZL",2,0,1,0);
    
    text(6,0,"SZL Verbauort:");
    INPAapiResultText(text_var,"SENSOR_VERBAUORT",1,"");
    ftextout(text_var,6,20,0,1);
    
    text(8,0,"SZL BMW Nummer:");
    INPAapiResultText(text_var,"SENSOR_BMW_NR",1,"");
    ftextout(text_var,8,20,0,1);
    
    text(10,0,"SZL Seriennummer:");
    INPAapiResultText(text_var,"SENSOR_PART_NR",1,"");
    ftextout(text_var,10,20,0,1);

    ftextout("Ident Sensorcluster",14,0,1,0);
   
    text(18,0,"Sensorcluster Verbauort:");
    INPAapiResultText(text_var,"SENSOR_VERBAUORT",2,"");
    ftextout(text_var,18,20,0,1);
    
    text(20,0,"Sensorcluster BMW Nummer:");
    INPAapiResultText(text_var,"SENSOR_BMW_NR",2,"");
    ftextout(text_var,20,20,0,1);
    
    text(22,0,"Sensorcluster Seriennummer:");
    INPAapiResultText(text_var,"SENSOR_PART_NR",2,"");
    ftextout(text_var,22,20,0,1);    
  }      
}

// ********************************************
// *** Statusscreen Ident Sensorcluster  ***
// ********************************************

 SCREEN s_status_cluster()

{
  ftextout("Ident Sensorcluster",1,0,1,0);
  ftextout("",3,0,0,0);

  INPAapiCheckJobStatus("OKAY");

  LINE ( "Anzahl Subbusteilnehmer", "")
  {
    INPAapiJob(sgbd,"SENSOREN_ANZAHL_LESEN","","");
    
    ftextout("Anzahl Subbusteilnehmer:",1,0,1,0);
    INPAapiResultText(text_var,"SENSOR_ANZAHL",1,"");
    ftextout(text_var,1,40,1,1);   
  }

  LINE ( "Ident Sensorcluster", "")
  {
    INPAapiJob(sgbd,"SENSOREN_IDENT_LESEN","","");

    ftextout("Ident Sensorcluster",2,0,1,0);
    
    text(6,0,"Sensorcluster Verbauort:");
    INPAapiResultText(text_var,"SENSOR_VERBAUORT",1,"");
    ftextout(text_var,6,20,0,1);
    
    text(8,0,"Sensorcluster BMW Nummer:");
    INPAapiResultText(text_var,"SENSOR_BMW_NR",1,"");
    ftextout(text_var,8,20,0,1);
    
    text(10,0,"Sensorcluster Seriennummer:");
    INPAapiResultText(text_var,"SENSOR_PART_NR",1,"");
    ftextout(text_var,10,20,0,1);
  }      
}



// ******************************
// *** Ende Statusscreen      ***
// ******************************

// **************************
// *** Steuernscreen      ***  
// **************************
SCREEN s_steuern()

{
  ftextout("Ansteuern",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("Ansteuern","")
  {
    ftextout("< F1 > Ventilansteuerung/Entlueftungsroutinen"      ,2, 5,0,1);

  if ((diag_index =="E90X_P") || (diag_index =="E60X_P") || (diag_index =="E60X"))
   {ftextout("< F2 > X-Drive Test "     ,4, 5,0,1);
    }
    
    ftextout("< F3 > Abgleich Laengsbeschleunigung",6, 5,0,1);
   
/*
    if ((diag_index =="E90X_P"))
    {
    ftextout("< F4 > Abgleich Lenkwinkel",8, 5,0,1);
    }
*/
    ftextout("< F9 > Drucken"                           ,18, 5,0,1);
    ftextout("< F10 >Zurück"                            ,20, 5,0,1);
    ftextout("Shift + < F10 > Exit"                     ,20, 45,0,1);
     
  }
}

// **************************
// *** DXC Steuernscreen  ***  
// **************************
SCREEN s_steuern_entl()
{
  ftextout("Hydraulik ansteuern",1,0,1,0);
  ftextout("",3,0,0,0);
  LINE("DXC-Ansteuern","")
  {

    ftextout("< F1 > Entlueften HL (immer mit F1 starten, dann F2, F3, F4)"     ,4, 5,0,1);
    ftextout("< F2 > Entlueften VL"     ,6, 5,0,1);
    ftextout("< F3 > Entlueften VR"     ,8, 5,0,1);
    ftextout("< F4 > Entlueften HR"     ,10, 5,0,1);
//    ftextout("< F5 > Ventilansteuerung"          ,2, 5,0,1);
    
    ftextout("< F9 > Drucken"                           ,18, 5,0,1);
    ftextout("< F10 >Zurück"                            ,20, 5,0,1);
    ftextout("Shift + < F10 > Exit"                     ,20, 45,0,1);
/*    
      LINE("Einlaß Ventil vorne links","EVVL"){}
      LINE("Einlaß Ventil vorne rechts","EVVR"){}
      LINE("Einlaß Ventil hinten links","EVHL"){}
      LINE("Einlaß Ventil hinten rechts","EVHR"){}
      LINE("Auslaß Ventil vorne links","AVVL"){}
      LINE("Auslaß Ventil vorne rechts","AVVR"){}
      LINE("Auslaß Ventil hinten links","AVHL"){}
      LINE("Auslaß Ventil hinten rechts","AVHR"){}
      LINE("ASC/DSC Sonderventil Vorder achse SV1","SV1"){}
      LINE("ASC/DSC Sonderventil Hinter achse SV2","SV2"){}
      LINE("ASC/DSC Umschalt ventil Vorder achse EUV1","EUV1"){}
      LINE("ASC/DSC Umschalt ventil Hinter achse EUV2","EUV2"){}    
      LINE("Rueckfoerderpumpe","Pumpe"){} 
 */     
  }
}

// ********************************************
// *** Statusscreen Taster Audio/Telefon    ***  // NEU 04.03.04 AB
// ********************************************

SCREEN s_status_audio_tel()

{
  
  ftextout("Taster Audio/Telefon",1,0,1,1);
  ftextout("",3,0,0,0);

  INPAapiCheckJobStatus("OKAY");

    INPAapiJob(sgbd,"STATUS_F_CAN_TASTER_AUDIO_TEL","","");
    
    ftextout("Taster Telefon:",5,0,1,0);
    INPAapiResultText(text_var,"STAT_TASTER_TELEFON_TEXT",1,"");
    clearrect(7,5,1,40);
    ftextout(text_var+"                    ",7,5,1,1);
    INPAapiResultInt(int_var,"STAT_TASTER_TELEFON",1);
    inttostring(int_var,text_var);
    ftextout(text_var,7,0,1,1);          

    ftextout("Audio Lautstaerke:",5,45,1,0);
    INPAapiResultText(text_var,"STAT_TASTER_AUDIO_LAUTSTAERKE_TEXT",1,"");
    clearrect(7,50,1,40);
    ftextout(text_var+"                    ",7,50,1,1);
    INPAapiResultInt(int_var,"STAT_TASTER_AUDIO_LAUTSTAERKE",1);
    inttostring(int_var,text_var);
    ftextout(text_var,7,45,1,1);          

    ftextout("Audio Suchlauf:",10,0,1,0);
    INPAapiResultText(text_var,"STAT_TASTER_AUDIO_SUCHLAUF_TEXT",1,"");
    clearrect(12,5,1,40);
    ftextout(text_var+"                    ",12,5,1,1);
    INPAapiResultInt(int_var,"STAT_TASTER_AUDIO_SUCHLAUF",1);
    inttostring(int_var,text_var);
    ftextout(text_var,12,0,1,1);          
/*  
    ftextout("Taster Horn:",10,45,1,0);
    INPAapiResultText(text_var,"STAT_TASTER_HORN_TEXT",1,"");
    ftextout(text_var,12,50,1,1);
    INPAapiResultInt(int_var,"STAT_TASTER_HORN",1);
    inttostring(int_var,text_var);
    ftextout(text_var,12,45,1,1);          
 */
    ftextout("Taster Hear:",15,0,1,0);
    INPAapiResultText(text_var,"STAT_TASTER_PUSH_TO_HEAR_TEXT",1,"");
    clearrect(17,5,1,40);
    ftextout(text_var+"                   ",17,5,1,1);
    INPAapiResultInt(int_var,"STAT_TASTER_PUSH_TO_HEAR",1);
    inttostring(int_var,text_var);
    ftextout(text_var,17,0,1,1);          

    ftextout("Taster Sonderfunktion:",15,45,1,0);
    INPAapiResultText(text_var,"STAT_TASTER_SONDERFUNKTION_TEXT",1,"");
    clearrect(17,50,1,40);
    ftextout(text_var+"                   ",17,50,1,1);
    INPAapiResultInt(int_var,"STAT_TASTER_SONDERFUNKTION",1);
    inttostring(int_var,text_var);
    ftextout(text_var,17,45,1,1);          

    ftextout("Taster Talk:",10,45,1,0);
    INPAapiResultText(text_var,"STAT_TASTER_PUSH_TO_TALK_TEXT",1,"");
    clearrect(12,50,1,40);
    ftextout(text_var+"                   ",12,50,1,1);
    INPAapiResultInt(int_var,"STAT_TASTER_PUSH_TO_TALK",1);
    inttostring(int_var,text_var);
    ftextout(text_var,12,45,1,1);          
}

// ********************************************
// *** Statusscreen Wischertaster           ***  // NEU 04.03.04 AB
// ********************************************

SCREEN s_status_wischer()

{
  
  ftextout("Wischertaster",1,0,1,1);
  ftextout("",3,0,0,0);

  INPAapiCheckJobStatus("OKAY");

    INPAapiJob(sgbd,"STATUS_F_CAN_WISCHERTASTER","","");

    ftextout("Wischertaster:",5,0,1,0);
    INPAapiResultText(text_var,"STAT_WISCHERTASTER_TEXT",1,"");
    clearrect(7,5,1,40);
    ftextout(text_var+"                    ",7,5,1,1);
    INPAapiResultInt(int_var,"STAT_WISCHERTASTER",1);
    inttostring(int_var,text_var);
    ftextout(text_var,7,0,1,1);              

    ftextout("Wischerpoti:",10,0,1,0);
    INPAapiResultText(text_var,"STAT_WISCHERPOTI_TEXT",1,"");
    clearrect(12,5,1,40);
    ftextout(text_var+"                    ",12,5,1,1);
    INPAapiResultInt(int_var,"STAT_WISCHERPOTI",1);
    inttostring(int_var,text_var);
    ftextout(text_var,12,0,1,1);             
}


// ********************************************
// *** Statusscreen Tempomat/ACC            ***  // NEU 04.03.04 AB
// ********************************************

SCREEN s_status_tempomat_acc()
{
  
  ftextout("Tempomat/ACC",1,0,1,1);
  ftextout("",3,0,0,0);

   INPAapiCheckJobStatus("OKAY");

    INPAapiJob(sgbd,"STATUS_F_CAN_TEMPOMAT_ACC","","");
    
    ftextout("Taster Tempomat:",5,0,1,0);
    INPAapiResultText(text_var,"STAT_TASTER_TEMPOMAT_ACC_TEXT",1,"");
    clearrect(7,5,1,40);
    ftextout(text_var+"                        ",7,5,1,1);
    INPAapiResultInt(int_var,"STAT_TASTER_TEMPOMAT_ACC",1);
    inttostring(int_var,text_var);
    ftextout(text_var,7,0,1,1);               

    ftextout("Abstandswahl:",10,0,1,0);
    INPAapiResultText(text_var,"STAT_ABSTANDSWAHL_ACC_TEXT",1,"");
    clearrect(12,5,1,40);
    ftextout(text_var+"                       ",12,5,1,1);
    INPAapiResultInt(int_var,"STAT_ABSTANDSWAHL_ACC",1);
    inttostring(int_var,text_var);
    ftextout(text_var,12,0,1,1);          
   /*
    ftextout("Modulwahl:",15,0,1,0);
    INPAapiResultText(text_var,"STAT_MODUS_WAHL_CC_CA_TEXT",1,"");
    clearrect(17,5,1,40);
    ftextout(text_var+"                           ",17,5,1,1);
    INPAapiResultInt(int_var,"STAT_MODUS_WAHL_CC_CA",1);
    inttostring(int_var,text_var);
    ftextout(text_var,17,0,1,1);
    */            
}

// -- EOF --
